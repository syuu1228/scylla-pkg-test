#!groovy
// Pipeline byo
// Get on which branches to run: build, tests, dtest.

Map modules = [:]
String sectionHeaderStyle = '''
color: white;
background: green;
font-family: Roboto, sans-serif !important;
padding: 5px;
text-align: center;
'''

String separatorStyle = '''
border: 0;
border-bottom: 1px dashed #ccc;
background: #999;
'''

properties([
  parameters([
	[
		$class: 'ParameterSeparatorDefinition',
		name: 'REPOS_BRANCHES',
		sectionHeader: 'Repos and Branches Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	string(name: 'DEFAULT_PRODUCT', defaultValue: 'scylla', description: 'Default product for all repos, unless specified otherwise.'),
	choice(name: 'DEFAULT_BRANCH', choices: ['next','master'], description: 'Default branch for all repos, unless specified otherwise.'),
	choice(name: 'SCYLLA_REPO', choices: ['git@github.com:scylladb/${DEFAULT_PRODUCT}.git','git@github.com:scylladb/scylla.git','git@github.com:scylladb/scylla-dev.git','git@github.com:scylladb/seastar-dev.git'], description: 'Scylla git repository to use. Use scylladb/seastar-dev.git for development branches.(Private repo\'s must have all submodule repos as siblings)'),
	string(name: 'SCYLLA_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: ''),
	string(name: 'SCYLLA_FORK_REPO', defaultValue: '', description: 'Scylla fork repo url for debug only.Must be use together with SCYLLA_FORK_BRANCH'),
	string(name: 'SCYLLA_FORK_BRANCH', defaultValue: '', description: 'Scylla fork repo branch for debug only. Must be use together with SCYLLA_FORK_REPO'),
	string(name: 'DTEST_REPO', defaultValue: 'git@github.com:scylladb/${DEFAULT_PRODUCT}-dtest.git', description: ''),
	string(name: 'DTEST_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: ''),
	string(name: 'MACHINE_IMAGE_REPO', defaultValue: 'git@github.com:scylladb/${DEFAULT_PRODUCT}-machine-image.git', description: 'Needed if you want to build centos-rpm'),
	string(name: 'MACHINE_IMAGE_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: ''),
	string(name: 'CCM_REPO', defaultValue: 'git@github.com:scylladb/${DEFAULT_PRODUCT}-ccm.git', description: ''),
	string(name: 'CCM_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: ''),
	string(name: 'SCT_REPO', defaultValue: 'git@github.com:scylladb/scylla-cluster-tests.git', description: ''),
	string(name: 'SCT_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: ''),
	string(name: 'RELENG_REPO', defaultValue: 'git@github.com:scylladb/${DEFAULT_PRODUCT}-pkg.git', description: 'Pay attention that this controls the job parameters. Be sure to give a default that contains the parameters directive. If changed here, should also change on pipeline section'),
	string(name: 'RELENG_BRANCH', defaultValue: '${DEFAULT_BRANCH}', description: 'Pay attention that this controls the job parameters. Be sure to give a default that contains the parameters directive. If changed here, should also change on pipeline section'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'BUILD_COMPILE',
		sectionHeader: 'Build and Compile Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	string(name: 'BUILD_MODE', defaultValue: 'dev', description: 'Choose: dev | release | debug or set empty for all'),
	booleanParam(name: 'TEST_DEBUG_INFO', defaultValue: false, description: 'Set this to get full test debug info (+ 200 GB on disk).'),
	string(name: 'SPECIAL_CONFIGURE_PY_PARAMS', defaultValue: '', description: 'Any special parameters to pass to configure.py (pass the whole flag. example: --cflags="VALUE")'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'TESTS',
		sectionHeader: 'Tests Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	booleanParam(name: 'ENABLE_MICRO_BENCHMARKS', defaultValue: false, description: 'Check this to run Micro Bench Marks and its analyzer'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'UNITTESTS',
		sectionHeader: 'Unittests Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	booleanParam(name: 'ENABLE_TESTS', defaultValue: true, description: 'Uncheck to skip unit tests'),
	string(name: 'X86_NUM_OF_UNITTEST_REPEATS', defaultValue: '1', description: 'Define the number of repeats for each test in unittests'),
	string(name: 'INCLUDE_TESTS', defaultValue: '' , description: 'Specify which tests to run. Leave empty for all. example: database_test'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'DTEST',
		sectionHeader: 'Dtest Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	booleanParam(name: 'ENABLE_DTEST', defaultValue: true, description: 'Uncheck to skip dtest'),
	booleanParam(name: 'DTEST_DEBUG_INFO', defaultValue: false, description: 'Check this to set env PRINT_DEBUG=true and DEBUG=true when running dtest'),
	booleanParam(name: 'DTEST_KEEP_LOGS', defaultValue: false, description: 'Check this, to keep dtest logs (set KEEP_LOGS=true)'),
	choice(name: 'TEST_RUNNER', choices: ['nosetests','pytests'], description: 'Which test runner to run'),
	string(name: 'INCLUDE_DTESTS', defaultValue: 'gating' , description: 'Specify which dtests to run. Leave empty for all. gating - for next tests (2-4 hours). Any list of tests, space separated. cql_additional_tests.py:TestCQL.keyspace_test - just an example of a specific test. Pay attention to syntax. Tests should be separated by spaces, attributes by commas.'),
	string(name: 'EXCLUDE_DTESTS', defaultValue: '', description: 'Specify dtests to exclude.'),
	string(name: 'NUMBER_RANDOM_DTESTS', defaultValue: '', description: 'Specify number of random dtests to run. (Leave empty for none [default]; set to "all" to shuffle all tests)'),
	string(name: 'RANDOM_DTESTS_SEED', defaultValue: '', description: 'Optionally specify a random seed for reproducing a run of random dtests (printed as `random_seed` by dtest.sh)'),
	string(name: 'SCYLLA_EXT_OPTS_EXTRA_SETTINGS', defaultValue: '--abort-on-seastar-bad-alloc --abort-on-lsa-bad-alloc=1', description: 'Anything you put here will be added to any default settings of SCYLLA_EXT_OPTS env var sent to nose.'),
	string(name: 'SCYLLA_EXT_ENV_EXTRA_SETTINGS', defaultValue: 'ASAN_OPTIONS=disable_coredump=0:abort_on_error=1;UBSAN_OPTIONS=halt_on_error=1:abort_on_error=1;BOOST_TEST_CATCH_SYSTEM_ERRORS=no', description: 'Anything you put here will be added to any default settings of SCYLLA_EXT_ENV env var sent to nose.'),
	string(name: 'NUM_OF_DTEST_REPEATS', defaultValue: '1', description: 'Define the number of repeats for each dtest.'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'PACKAGE',
		sectionHeader: 'Package Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	booleanParam(name: 'CREATE_CENTOS_RPM', defaultValue: false, description: 'Check this to build CentOS RPM packages'),
	booleanParam(name: 'CREATE_UNIFIED_DEB', defaultValue: false, description: 'Check this to build Unified Deb packages'),
	booleanParam(name: 'CREATE_AMI', defaultValue: false, description: 'Check this to build AMI (based on latest Unified-deb repo on S3) packages'),
	booleanParam(name: 'CREATE_GCE', defaultValue: false, description: 'Check this if you need an GCE image based on latest unified-deb on S3 (it uploads to amazonaws)'),
	booleanParam(name: 'CREATE_AZURE', defaultValue: false, description: 'Check this if you need an Azure image based on latest unified-deb on S3 (it uploads to amazonaws)'),

	[
		$class: 'ParameterSeparatorDefinition',
		name: 'GENERAL',
		sectionHeader: 'General Parameters',
		separatorStyle: separatorStyle,
		sectionHeaderStyle: sectionHeaderStyle
	],
	string(name: 'X86_NODE_PARAM', defaultValue: 'pack-no-muninn', description: 'Mandatory. Useful options: packager,loki,dgccd201,thor,ran,sif,huginn,muninn and gce-leader'),
	string(name: 'TIMEOUT_PARAM', defaultValue: '12', description: 'Build timeout (in hours)'),
	booleanParam(name: 'PRESERVE_WORKSPACE', defaultValue: false, description: 'Check this if you need the workspace to remain (for debug)'),
	booleanParam(name: 'DEBUG_MAIL', defaultValue: true, description: 'Uncheck if you want mail to rnd-int. Default is to sent to build requester only (you).'),
	booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Check this to check pipeline syntax. will not perform anything.')
  ])
])

pipeline {
	agent {
		label {
			label env.X86_NODE_PARAM
		}
	}

	environment {
		SCYLLA_GPG_PRIVATE_KEY = credentials('scylladb-package-signing-key-2020')
		SCYLLA_GPG_PUBLIC_KEY = credentials('scylladb-package-signing-key-2020-public')
		SCYLLA_GPG_KEYID = credentials('scylladb-package-signing-key-2020-public-keyid')
		AWS_ACCESS_KEY_ID     = credentials('jenkins2-aws-secret-key-id')
		AWS_SECRET_ACCESS_KEY = credentials('jenkins2-aws-secret-access-key')
	}

  options {
		timeout(time: env.TIMEOUT_PARAM, unit: 'HOURS')
    buildDiscarder(
			logRotator(
				numToKeepStr: '40',
				daysToKeepStr: '14'
			)
		)
		copyArtifactPermission('*centos-rpm*,*dtest*,*unified-deb*,*unittests*,*driver-matrix*,*byo*,*microbenchmarks*')
	}

	stages {

		stage ('Prepare') {
			steps {
				script {
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					general = load "${generalProperties.groovyPath}/general.groovy"
					general.initPipeline()

					if (params.ENABLE_TESTS) {
						withArtifacts = ""
					} else {
						withArtifacts = "scylla"
					}

					if (params.BUILD_MODE == "" && params.ENABLE_DTEST) {
						error ("Can't run dtest on all modes (will be too long). Please specify a specific BUILD_MODE to run dtest. If you want to run dtest on all modes, use this build just to build, and use byo-dtest to run dtest on the build you created on any mode.")
					}

					testFailed = false
					dtestFailed = false
					failedTestModes = ""

					buildTestModesList = general.buildModesList(params.BUILD_MODE)
					buildTestModesString = buildTestModesList.join(", ")

					dtestText = "Dtest. Tests to include: |${params.INCLUDE_DTESTS}|. Tests to exclude |${params.EXCLUDE_DTESTS}|"
					amiWorkDir = "$WORKSPACE/${gitProperties.scyllaMachineImageCheckoutDir}/aws/ami"

					buildPackages = params.CREATE_CENTOS_RPM || params.CREATE_UNIFIED_DEB || params.CREATE_AMI
					logText += " Please note that tests and dtest build log files are available as build artifacts. Search for *_output.txt"
					scyllaCouldStoragePath = "byo" //We dont upload to S3 on byo
					buildDebugPackages = (params.BUILD_MODE == "debug" || params.BUILD_MODE == "")
					buildReleasePackages = (params.BUILD_MODE == "release" || params.BUILD_MODE == "")
					(utcTextTimeStamp, urlId) = artifact.cloudBuildIdPath ()
					targetRelocUrl = general.setTestingUrlIfNeeded ("${branchProperties.relocPackageCloudPathPrefix}/$urlId")
					targetBuildPackagesUrl = general.setTestingUrlIfNeeded ("${branchProperties.buildPackagesCloudPathPrefix}/$urlId")
				}
			}
		}

		stage('Checkout') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					scyllaSha = git.checkoutToDir(params.SCYLLA_REPO, params.SCYLLA_BRANCH, gitProperties.scyllaCheckoutDir)
					if (params.SCYLLA_FORK_REPO && params.SCYLLA_FORK_BRANCH) {
						git.useScyllaForkRepo(params.SCYLLA_FORK_REPO, params.SCYLLA_FORK_BRANCH, gitProperties.scyllaCheckoutDir)
					}
					git.checkoutToDir (params.RELENG_REPO, params.RELENG_BRANCH, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)
					if (params.ENABLE_DTEST) {
						git.checkoutToDir (params.DTEST_REPO, params.DTEST_BRANCH, gitProperties.scyllaDtestCheckoutDir)
						git.checkoutToDir (params.CCM_REPO, params.CCM_BRANCH, gitProperties.scyllaCcmCheckoutDir)
					}

					if (params.CREATE_CENTOS_RPM || params.CREATE_UNIFIED_DEB || params.CREATE_AMI || params.CREATE_GCE || params.CREATE_AZURE) {
						git.checkoutToDir (params.MACHINE_IMAGE_REPO, params.MACHINE_IMAGE_BRANCH, gitProperties.scyllaMachineImageCheckoutDir)
					}

					if (params.ENABLE_MICRO_BENCHMARKS) {
						git.checkoutToDir(params.SCT_REPO, params.SCT_BRANCH, generalProperties.scyllaClusterTestsCheckoutDir)
					}

					general.lsPath (WORKSPACE, "Workspace content after check-outs")
				}
			}
		}

		stage('Build') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					(utcTextTimeStamp, urlId) = artifact.cloudBuildIdPath ()

					build.scyllaDistBuild (
						testsDebugInfoFlag: params.TEST_DEBUG_INFO,
						dryRun: params.DRY_RUN,
						buildMode: params.BUILD_MODE,
						withArtifacts: withArtifacts,
						buildDocker: false,
						userRequestedParam: params.SPECIAL_CONFIGURE_PY_PARAMS)

					(scyllaId, scyllaVersion) = build.createDistBuildMetadataFile (
						dryRun: params.DRY_RUN,
						scyllaSha: scyllaSha,
						urlId: urlId,
						buildMode: buildTestModesString,
						utcTextTimeStamp: utcTextTimeStamp,
						baseRelocCloudStorageUrl: targetRelocUrl,
						baseBuildPackagesCloudStorageUrl: targetBuildPackagesUrl,
					)
					artifact.publishMetadataFile()

					uploadGeneralModeArtifacts = true
					buildTestModesList.each { buildMode ->
						build.publishScyllaDistArtifacts (
							dryRun: params.DRY_RUN,
							scyllaRelocFullUrl: targetRelocUrl,
							scyllaBuildPackagesFullUrl: targetBuildPackagesUrl,
							buildMode: buildMode,
							uploadGeneralModeArtifacts: uploadGeneralModeArtifacts,
							uploadToCloudStorage: true,
						)
						uploadGeneralModeArtifacts = false
					}
				}
			}
		}

		stage('Create CentOS RPM Repo') {
			when {
				expression {params.CREATE_CENTOS_RPM}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					rpmUrl = general.setTestingUrlIfNeeded ("${branchProperties.scyllaDownloadsRpmUnstablePath}/$urlId/")
					build.machineImageBuild(params.DRY_RUN)
					if (buildReleasePackages) {
						build.prepareBuildRpm (
							dryRun: params.DRY_RUN,
							mainMode: true,
							downloadFromCloud: false,
							cloudUrl: "none",
							artifactSourceJob: "none",
							artifactSourceJobNum: "none",
							scyllaUrlID: scyllaCouldStoragePath,
							rpmUrl: rpmUrl,
							buildMode: "release",
						)
					}

					if (buildDebugPackages) {
						build.prepareBuildRpm (
							dryRun: params.DRY_RUN,
							mainMode: !buildReleasePackages,
							downloadFromCloud: false,
							cloudUrl: "none",
							artifactSourceJob: "none",
							artifactSourceJobNum: "none",
							scyllaUrlID: "$scyllaCouldStoragePath/${branchProperties.debugProductName}",
							rpmUrl: rpmUrl,
							buildMode: "debug",
						)
					}
				}
			}
		}

		stage('Create debian Repo') {
			when {
				expression {params.CREATE_UNIFIED_DEB || params.CREATE_AMI || params.CREATE_GCE || params.CREATE_AZURE}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					scyllaDebUrl = general.setTestingUrlIfNeeded ("${branchProperties.scyllaDownloadsDebianUnstablePath}/$urlId/")
					if (buildReleasePackages) {
						build.prepareBuildDebPkg (
							dryRun: params.DRY_RUN,
							mainMode: true,
							downloadFromCloud: false,
							cloudUrl: "none",
							artifactSourceJob: "none",
							artifactSourceJobNum: "none",
							scyllaUrlID: scyllaCouldStoragePath,
							scyllaUnifiedDebUrl: scyllaDebUrl,
							buildMode: "release",
						)
						scyllaDebListFileUrl = "${scyllaDebUrl}${branchProperties.scyllaUnifiedPkgRepo}/${branchProperties.listFileName}"
					}
					if (buildDebugPackages) {
						build.prepareBuildDebPkg (
							dryRun: params.DRY_RUN,
							mainMode: !buildReleasePackages,
							downloadFromCloud: false,
							cloudUrl: "none",
							artifactSourceJob: "none",
							artifactSourceJobNum: "none",
							scyllaUrlID: "$scyllaCouldStoragePath/${branchProperties.debugProductName}",
							scyllaUnifiedDebUrl: scyllaDebUrl,
							buildMode: "debug",
						)
					}
				}
			}
		}

		stage('Build AMI') {
			when {
				expression {params.CREATE_AMI}
			}
			steps {
				script {
					dpackagerAwsCommand = general.setAwsDpackagerCommand ("", "$WORKSPACE/${gitProperties.scyllaPkgCheckoutDir}")
					build.buildAmi (dryRun: params.DRY_RUN,
						amiWorkDir: "$WORKSPACE/${gitProperties.scyllaMachineImageCheckoutDir}/aws/ami",
						productName: "scylla",
						amiPropertiesFile:"$WORKSPACE/${generalProperties.amiIdFile}",
						dpackagerAwsCommand: dpackagerAwsCommand,
						repoUrl: "${branchProperties.latestUnifiedOSUrl}${branchProperties.scyllaUnifiedPkgRepo}/${branchProperties.listFileName}",
						osDistro: "ubuntu:20.04",
					)
				}
			}
		}

		stage('Build GCE image') {
			when {
				expression {params.CREATE_GCE}
			}
			steps {
				script {
					build.buildGce(
						dryRun: params.DRY_RUN,
						baseUrl: scyllaDebListFileUrl,
						osDistro: "ubuntu:20.04",
					)
					artifact.addLineToBuildMetadataFile("scylla-gce-image-id", gceImageId)
					artifact.addLineToBuildMetadataFile("scylla-gce-image-db", gceImageDbUrl)
					artifact.publishMetadataFile()
				}
			}
		}

		stage('Build Azure image') {
			when {
				expression {params.CREATE_AZURE}
			}
			steps {
				script {
					(azureImageId, azureImageName) = build.buildAzure(
						dryRun: params.DRY_RUN,
						listFileUrl: scyllaDebListFileUrl,
					)
					artifact.addLineToBuildMetadataFile("azure-image-id", azureImageId)
					artifact.addLineToBuildMetadataFile("azure-image-name", azureImageName)
					artifact.publishMetadataFile()
				}
			}
		}

		stage('Test') {
			when {
				expression { params.ENABLE_TESTS }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					int numberOfTestFails = 0
					int numberOfFailingModes = 0
					String allTestResultDetails = ""

					buildTestModesList.each { testMode ->
						boolean modeTestsFailed = false
						int numberOfModeTestFails = 0
						String testResultSummary = ""
						String modeTestResultDetails = ""
						try {
							(modeTestsFailed, numberOfModeTestFails, testResultSummary, modeTestResultDetails) = test.doTest (
								dryRun: params.DRY_RUN,
								testMode: testMode,
								includeTests: params.INCLUDE_TESTS,
								numOfRepeats: params.X86_NUM_OF_UNITTEST_REPEATS)
						} catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException interruptEx) {
							testFailed = true
							currentBuild.result = 'ABORTED'
							error ("Interrupt exception (abort) while Test phase, error: |$interruptEx|")
						} finally {
							if (currentBuild.currentResult == 'ABORTED') {
								error ("Interrupt exception (abort) while Test phase.")
							} else if (modeTestsFailed) {
								testFailed = true
								echo "Error: tests phase failed, going on with other test modes and dtest"
								numberOfTestFails = numberOfTestFails + numberOfModeTestFails
								allTestResultDetails = "$allTestResultDetails\n$modeTestResultDetails"
								numberOfFailingModes ++
								if (!failedTestModes) {
									failedTestModes = "Failed test modes: $testMode"
								} else {
									failedTestModes = "$failedTestModes, $testMode"
								}
							}
						}
					}
				}
			}
		}

		stage('dtest') {
			when {
				expression { params.ENABLE_DTEST }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					dtestFailed = callDtest ()
				}
			}
		}

		stage('Check Tests Status') {
			when {
				expression { params.ENABLE_TESTS || params.ENABLE_DTEST }
			}
			// I need this to determine test and dtest status. I used try and catch to enable both to finish, even if one failed.
			steps {
				script {
					lastStage = "Test and dtest"
					if (testFailed && dtestFailed) {
						error ("$failedTestModes and dtest failed")
					} else if (testFailed) {
						lastStage = "Test"
						error ("$failedTestModes")
					} else if (dtestFailed) {
						lastStage = "dtest"
						error("dtest Failed")
					}
				}
			}
		}

		stage('MicroBenchmarks') {
			when {
				expression { params.ENABLE_MICRO_BENCHMARKS }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					test.microBenchMarks(params.DRY_RUN)
				}
			}
		}

		stage('MicroBenchmarks Analyzer') {
			when {
				expression { params.ENABLE_MICRO_BENCHMARKS }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					debugBuild = true
					test.microBenchMarksAnalyzer(params.DRY_RUN, "$devAddress", debugBuild)
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('initPipelineDone')) {
					mail.mailIfError("$devAddress", "${currentBuild.currentResult} stage $lastStage: $jobTitle", "${currentBuild.currentResult}: $jobTitle on stage $lastStage: $logText")
					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
				} else {
					cleanWs()
				}
			}
		}

		fixed {
			script {
				mail.mailFixed("$devAddress", "Fixed ${currentBuild.currentResult}: $jobTitle", "Fixed ${currentBuild.currentResult}: $jobTitle: $logText")
			}
		}
	}
}

boolean callDtest() {
	// This is a very light function to avoid local code duplication. I use global vars instead of duplicating a long call line
	dtestFailed = false
	if (params.ENABLE_DTEST) {
		echo "$dtestText"
		try {
			test.doDtest (
				dryRun: params.DRY_RUN,
				dtestMode: params.BUILD_MODE,
				testRunner: params.TEST_RUNNER,
				dtestDebugInfoFlag: params.DTEST_DEBUG_INFO,
				dtestKeepLogsFlag: params.DTEST_KEEP_LOGS,
				excludeTests: params.EXCLUDE_DTESTS,
				includeTests: params.INCLUDE_DTESTS,
				extOpts: params.SCYLLA_EXT_OPTS_EXTRA_SETTINGS,
				extEnv: params.SCYLLA_EXT_ENV_EXTRA_SETTINGS,
				randomDtests: params.NUMBER_RANDOM_DTESTS,
				randomDtestsSeed: params.RANDOM_DTESTS_SEED,
				dtestRepeats: params.NUM_OF_DTEST_REPEATS,
				dtestType: "byo",
				architecture: branchProperties.x86ArchName,
			)

		} catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException interruptEx) {
			currentBuild.result = 'ABORTED'
			dtestFailed = true
			error("Interrupt exception (abort) while dtest. Error: |$interruptEx|, Going to exit.")
		} catch (error) {
			dtestFailed = true
			if (currentBuild.currentResult == 'ABORTED') {
				error("Interrupt exception (abort) while dtest phase. Error: |$error|. Going to exit.")
			} else {
				echo "Error: dtest phase failed, going ahead to check tests and dtest status"
			}
		}
	} else {
		echo "No Need to run dtest, upon user request"
	}
	return dtestFailed
}
