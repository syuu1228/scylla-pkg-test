#!groovy
// Pipeline next
// In order to debug, set RELENG_BRANCH on Jenkins job with value of the debug branch.
// example: refs/heads/build-pipeline-into-scm
// If you work on a fork, also set the RELENG_REPO with your fork such as git@github.com:hagitsegev/scylla-pkg or
// use the default repo of git@github.com:scylladb/scylla-pkg or git@github.com:scylladb/scylla-enterprise-pkg

Map modules = [:]
pipeline {
	parameters {
		// Mandatory
		string(name: 'X86_NODE_PARAM', defaultValue: 'ec2-fleet-next', description: 'Useful options: godzilla,monster,next-promoter-docker,loki,dgccd201,thor,ran,sif,huginn,muninn')

		// Optional
		string(name: 'TIMEOUT_PARAM', defaultValue: '7', description: 'Build timeout (in hours)')
		string(name: 'X86_NUM_OF_UNITTEST_REPEATS', defaultValue: '3', description: 'Define the number of repeats for each test in unittests')
		string(name: 'SCYLLA_EXT_OPTS_EXTRA_SETTINGS', defaultValue: '--abort-on-seastar-bad-alloc --abort-on-lsa-bad-alloc=1', description: 'Anything you put here will be added to any default settings of SCYLLA_EXT_OPTS env var sent to nose.')
		string(name: 'SCYLLA_EXT_ENV_EXTRA_SETTINGS', defaultValue: 'ASAN_OPTIONS=disable_coredump=0:abort_on_error=1;UBSAN_OPTIONS=halt_on_error=1:abort_on_error=1;BOOST_TEST_CATCH_SYSTEM_ERRORS=no', description: 'Anything you put here will be added to any default settings of SCYLLA_EXT_ENV env var sent to nose.')
		string(name: 'INCLUDE_DTESTS', defaultValue: 'gating' , description: 'Specify which dtests to run. Leave empty for all. gating - for next tests (2-4 hours). cql_additional_tests.py:TestCQL.keyspace_test - just an example of a specific test')
		string(name: 'EXCLUDE_DTESTS', defaultValue: '', description: 'Specify dtests to exclude.')
		string(name: 'INCLUDE_TESTS_ON_DEBUG', defaultValue: '' , description: 'Specify which tests to run. Leave empty for all. example: database_test. Affective only on debug builds')
		string(name: 'RELENG_REPO', defaultValue: '', description: 'Branch of pkg repo or fork. If empty - will take scylla-pkg repo (examples: git@github.com:scylladb/scylla-pkg, git@github.com:scylladb/scylla-enterprise-pkg, git@github.com:hagitsegev/scylla-pkg)')
		string(name: 'RELENG_BRANCH', defaultValue: '', description: 'Branch of pkg repo. If empty - will take next branch (next, next-3.1)')
		booleanParam(name: 'TEST_DEBUG_INFO', defaultValue: false, description: 'Set this to get full test debug info (+ 200 GB on disk).')
		booleanParam(name: 'SKIP_UNITTESTS_ON_DEBUG', defaultValue: false, description: 'Check this to skip unit testing. Relevant only when debug pkg branch is used')
		booleanParam(name: 'SKIP_DTEST_ON_DEBUG', defaultValue: false, description: 'Check this to skip dtest. Relevant only when debug pkg branch is used')
		booleanParam(name: 'PUBLISH_EVEN_ON_DEBUG', defaultValue: false, description: 'Check this to skip upload artifacts. Relevant only when debug pkg branch is used')
		booleanParam(name: 'DTEST_DEBUG_INFO', defaultValue: false, description: 'Check this to set env PRINT_DEBUG=true and DEBUG=true when running dtest')
		booleanParam(name: 'SKIP_LABEL_BACKPORT', defaultValue: false, description: 'Check to skip lable backport. Relevant only if the branch is set to do this - only master')
		booleanParam(name: 'PRESERVE_WORKSPACE', defaultValue: false, description: 'Check this if you need the workspace to remain (for debug)')
		booleanParam(name: 'DEBUG_MAIL', defaultValue: false, description: 'Uncheck if you want mail to rnd-int. Default is to sent to build requester only (you).')
		booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Check this to check pipeline syntax. will not perform anything.')
	}
	agent {
			label {
				label env.X86_NODE_PARAM
			}
	}

	environment {
		AWS_ACCESS_KEY_ID     = credentials('jenkins2-aws-secret-key-id')
		AWS_SECRET_ACCESS_KEY = credentials('jenkins2-aws-secret-access-key')
	}

	options {
		disableConcurrentBuilds()
		copyArtifactPermission('*centos-rpm*,*dtest*,*unified-deb*,*unittests*,*driver-matrix*,*byo*,*microbenchmarks*,*next*,*offline-installer*,*docker*')
		timeout(time: env.TIMEOUT_PARAM, unit: 'HOURS')
		buildDiscarder(
			logRotator(
				numToKeepStr: env.BRANCH_NAME == /next/ || env.BRANCH_NAME == /next-enterprise/ ? '100' : '30',
				daysToKeepStr: env.JOB_NAME.contains("releng-testing") ? '14': ''
			)
		)
	}

	stages {

		stage ('Prepare') {
			steps {
				script {
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					general = load "${generalProperties.groovyPath}/general.groovy"
					general.initPipeline()

					testStarted = false
					failedTestModes = ""
					buildPassed = false
					dtestFailed = false
					testFailed = false
					allTestResultDetails = ""
					scyllaPkg = "" // Needed only when we publish reloc to S3
					jobSummaryFile = "$WORKSPACE/${generalProperties.jobSummaryFile}"
					logText += " Please note that tests and dtest build log files are available as build artifacts. Search for *_output.txt"

					if ("${branchProperties.labelBackports}" == "true") { // properties are alwasy strings
						if (params.SKIP_LABEL_BACKPORT) {
							enableLabelBackport = false
						} else {
							enableLabelBackport = true
						}
					} else {
						enableLabelBackport = false
					}

					buildTestModesList = general.buildModesList("") // test all: release, debug, dev
					buildTestModesString = buildTestModesList.join(", ")

					relengTestingRun = jenkins.debugBuild()
					publishArtifacts = true
					if (relengTestingRun && !params.PUBLISH_EVEN_ON_DEBUG) {
						publishArtifacts = false
					}
					includeTestsOnDebug = ""
					if (params.INCLUDE_TESTS_ON_DEBUG && relengTestingRun) {
						includeTestsOnDebug = params.INCLUDE_TESTS_ON_DEBUG
					}
					(utcTextTimeStamp, urlId) = artifact.cloudBuildIdPath ()
					targetRelocUrl = general.setTestingUrlIfNeeded ("${branchProperties.relocPackageCloudPathPrefix}/$urlId")
					targetBuildPackagesUrl = general.setTestingUrlIfNeeded ("${branchProperties.buildPackagesCloudPathPrefix}/$urlId")
					nextInitsDone=true
				}
			}
		}

		stage('Checkout') {
			steps {
				script {
					relengBranch = params.RELENG_BRANCH ?: branchProperties.nextBranchName
					lastStage = env.STAGE_NAME
					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					git.createJobSummaryFiles(jobSummaryFile)
					scyllaNextSha = git.checkoutToDir(gitProperties.scyllaRepoUrl, branchProperties.nextBranchName, gitProperties.scyllaCheckoutDir)
					scyllaMasterSha = git.remoteBranchSha(gitProperties.scyllaRepoUrl, branchProperties.stableBranchName)
					listCommittersEmail	= mail.committerEmailAddress(branchProperties.nextBranchName, branchProperties.stableBranchName, "$WORKSPACE/${gitProperties.scyllaCheckoutDir}", params.DEBUG_MAIL)
					git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)
					git.checkoutToDir (gitProperties.scyllaDtestRepoUrl, branchProperties.nextBranchName, gitProperties.scyllaDtestCheckoutDir)
					git.checkoutToDir (gitProperties.scyllaCcmRepoUrl, branchProperties.nextBranchName, gitProperties.scyllaCcmCheckoutDir)

					general.lsPath (WORKSPACE, "Workspace content after check-outs")
				}
			}
		}

		stage('Build') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					build.scyllaDistBuild (
						testsDebugInfoFlag: params.TEST_DEBUG_INFO,
						dryRun: params.DRY_RUN,
						buildMode: "",
						withArtifacts: "",
						userRequestedParam: "")

					(scyllaId, scyllaVersion) = build.createDistBuildMetadataFile (
						dryRun: params.DRY_RUN,
						scyllaSha: scyllaNextSha,
						urlId: urlId,
						buildMode: buildTestModesString,
						utcTextTimeStamp: utcTextTimeStamp,
						baseRelocCloudStorageUrl: targetRelocUrl,
						baseBuildPackagesCloudStorageUrl: targetBuildPackagesUrl,
					)
					artifact.publishMetadataFile()
					buildPassed = true
				}
			}
		}

		stage('Smoke dtest') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					echo "Smoke dtest release. Tests to include: dtest-smoke"
					test.doDtest(
						dryRun: params.DRY_RUN,
						dtestMode: "release",
						dtestDebugInfoFlag: params.DTEST_DEBUG_INFO,
						dtestKeepLogsFlag: false,
						includeTests: "-a dtest-smoke",
						extOpts: params.SCYLLA_EXT_OPTS_EXTRA_SETTINGS,
						extEnv: params.SCYLLA_EXT_ENV_EXTRA_SETTINGS,
						dtestType: "smoke",
						architecture: branchProperties.x86ArchName,
					)
				}
			}
		}

		stage('Test') {
			when {
				expression { !(relengTestingRun && params.SKIP_UNITTESTS_ON_DEBUG) }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					int numberOfTestFails = 0
					int numberOfFailingModes = 0
					int numberOfTestedModes = 0

					buildTestModesList.each { testMode ->
						numberOfTestedModes ++
						boolean modeTestsFailed = false
						int numberOfModeTestFails = 0
						String testResultSummary = ""
						String modeTestResultDetails = ""
						try {
							(modeTestsFailed, numberOfModeTestFails, testResultSummary, modeTestResultDetails) = test.doTest (
								dryRun: params.DRY_RUN,
								testMode: testMode,
								includeTests: includeTestsOnDebug,
								numOfRepeats: params.X86_NUM_OF_UNITTEST_REPEATS)
						} catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException interruptEx) {
							testFailed = true
							currentBuild.result = 'ABORTED'
							error ("Interrupt exception (abort) while Test phase, error: |$interruptEx|")
						} finally {
							if (currentBuild.currentResult == 'ABORTED') {
								error ("Interrupt exception (abort) while Test phase.")
							} else if (modeTestsFailed) {
								testFailed = true
								echo "Error: tests phase failed, going on with other test modes and dtest"
								numberOfTestFails = numberOfTestFails + numberOfModeTestFails
								allTestResultDetails = "$allTestResultDetails\n$modeTestResultDetails"
								numberOfFailingModes ++
								if (!failedTestModes) {
									failedTestModes = "Failed test modes: $testMode"
								} else {
									failedTestModes = "$failedTestModes, $testMode"
								}
							}
							sh "echo '$testResultSummary' >> $jobSummaryFile"
						}
					}
					if (test.isflakyUnittest (
						dryRun: params.DRY_RUN,
						testFailed: testFailed,
						numberOfTestedModes: numberOfTestedModes,
						numberOfTestFails: numberOfTestFails,
						numberOfFailingModes: numberOfFailingModes,
						allTestResultDetails: allTestResultDetails,
						jobTitle: jobTitle,
						devAddress: devAddress)) {

						sh "echo 'isFlakyUnitTests=true' >> $jobSummaryFile"
					} else {
						sh "echo 'isFlakyUnitTests=false' >> $jobSummaryFile"
					}
				}
			}
		}

		stage('dtest') {
			when {
				expression { ! (relengTestingRun && params.SKIP_DTEST_ON_DEBUG) }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					echo "Dtest release. Tests to include: |${params.INCLUDE_DTESTS}|. Tests to exclude |${params.EXCLUDED_TESTS}|"
					try {
						test.doDtest(
							dryRun: params.DRY_RUN,
							dtestMode: "release",
							dtestDebugInfoFlag: params.DTEST_DEBUG_INFO,
							dtestKeepLogsFlag: false,
							excludeTests: params.EXCLUDE_DTESTS,
							includeTests: params.INCLUDE_DTESTS,
							extOpts: params.SCYLLA_EXT_OPTS_EXTRA_SETTINGS,
							extEnv: params.SCYLLA_EXT_ENV_EXTRA_SETTINGS,
							dtestType: "gating",
							architecture: branchProperties.x86ArchName,
						)

					} catch (org.jenkinsci.plugins.workflow.steps.FlowInterruptedException interruptEx) {
						dtestFailed = true
						currentBuild.result = 'ABORTED'
						error("Interrupt exception (abort) while dtest phase, error: |$interruptEx|")
					} catch (error) {
						dtestFailed = true
						if (currentBuild.currentResult == 'ABORTED') {
							error("Interrupt exception (abort) while dtest phase, error: |$error|")
						} else {
							echo "Error: dtest phase failed, going ahead to check tests and dtest status, error: |$error|"
						}
					}
				}
			}
		}

		stage('Check Tests Status') {
			when {
				expression { !(relengTestingRun && params.SKIP_DTEST_ON_DEBUG && params.SKIP_UNITTESTS_ON_DEBUG) }
			}
			// I need this to determine both test and dtest status. I used try and catch to enable both to finish, even if one failed.
			steps {
				script {
					lastStage = "Test and dtest"
					if (testFailed && dtestFailed) {
						error ("$failedTestModes and dtest failed\n$allTestResultDetails")
					} else if (testFailed) {
						lastStage = "Test"
						error ("$failedTestModes\n$allTestResultDetails")
					} else if (dtestFailed) {
						lastStage = "dtest"
						error("dtest Failed")
					}
				}
			}
		}

		stage('Push') {
			when {
				expression { !relengTestingRun && currentBuild.result == 'SUCCESS' }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					git.push2Git(branchProperties.nextBranchName, branchProperties.stableBranchName, params.DRY_RUN, "$WORKSPACE/${gitProperties.scyllaCheckoutDir}")
					git.push2Git(branchProperties.nextBranchName, branchProperties.stableBranchName, params.DRY_RUN, "$WORKSPACE/${gitProperties.scyllaCcmCheckoutDir}")
					git.push2Git(branchProperties.nextBranchName, branchProperties.stableBranchName, params.DRY_RUN, "$WORKSPACE/${gitProperties.scyllaDtestCheckoutDir}")
					if (relengBranch == "${branchProperties.nextBranchName}") {
						git.push2Git("${branchProperties.nextBranchName}", "${branchProperties.stableBranchName}", params.DRY_RUN, "$WORKSPACE/${gitProperties.scyllaPkgCheckoutDir}")
					} else {
						echo "This was not run on pkg next branch, not pushing ${gitProperties.scyllaPkgRepoUrl} branch ${relengBranch} to master"
					}
				}
			}
		}

		stage('Label backports') {
			when {
				expression { enableLabelBackport && currentBuild.result == 'SUCCESS' }
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					git.labelBackports(scyllaNextSha, scyllaMasterSha, params.DRY_RUN)
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('nextInitsDone')) {
					jenkins.isSpotTermination(lastStage)
					jenkins.setUnstableAsError(jobTitle)

					if (allTestResultDetails) {
						logText += "\n$allTestResultDetails"
					}

					if (buildPassed && publishArtifacts) {
						boolean uploadGeneralModeArtifacts = true
						buildTestModesList.each { buildMode ->
							build.publishScyllaDistArtifacts (
								dryRun: params.DRY_RUN,
								scyllaRelocFullUrl: targetRelocUrl,
								scyllaBuildPackagesFullUrl: targetBuildPackagesUrl,
								buildMode: buildMode,
								uploadGeneralModeArtifacts: uploadGeneralModeArtifacts,
							)
							uploadGeneralModeArtifacts = false
						}
					}
					errorMailAddress = devAddress
					if (binding.hasVariable('listCommittersEmail')) {
						errorMailAddress += ", $listCommittersEmail"
					}
					logText += general.runOrDryRunShOutput (false, "cat $generalProperties.jobSummaryFile", "Get job summary for mail")
					echo "Job Summary:"
					echo "=================================="
					echo "$logText"
					echo "=================================="
					mail.mailIfError(errorMailAddress, "$currentBuild.currentResult stage $lastStage: $jobTitle", "${currentBuild.currentResult}: $jobTitle on stage $lastStage: $logText")

					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
				} else if (!(JOB_NAME.contains("releng-testing") || params.DRY_RUN || params.DEBUG_MAIL)) {
					mail (
						to: "releng@scylladb.com",
						subject: "${currentBuild.currentResult}: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
						body: "${env.JOB_NAME} [${env.BUILD_NUMBER}] ${currentBuild.currentResult} at the very beginning. Please see Jenkins logs for details"
					)
					jobSummaryFile = "$WORKSPACE/job-summary-results.properties"
					sh """
						echo 'lastStage=Early stage' >> $jobSummaryFile
						echo 'result=$currentBuild.currentResult' >> $jobSummaryFile
					"""
					archiveArtifacts "job-summary-results.properties"
					cleanWs()
				} else {
					cleanWs()
				}
			}
		}

		fixed {
			script {
				mail.mailFixed("$devAddress", "Fixed ${currentBuild.currentResult}: $jobTitle", "Fixed ${currentBuild.currentResult}: $jobTitle")
			}
		}
	}
}
