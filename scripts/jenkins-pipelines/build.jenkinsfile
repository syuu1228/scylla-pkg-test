#!groovy
// Pipeline build
// In order to debug, set RELENG_BRANCH on Jenkins job with value of the debug branch.
// example: refs/heads/build-pipeline-into-scm
// If you work on a fork, also set the RELENG_REPO with your fork such as git@github.com:hagitsegev/scylla-pkg or
// use the default repo of git@github.com:scylladb/scylla-pkg or git@github.com:scylladb/scylla-enterprise-pkg

Map modules = [:]
pipeline {
	parameters {
		// Mandatory
		string(name: 'X86_NODE_PARAM', defaultValue: 'ec2-fleet-next', description: 'Node or label to build x86. Use "NONE" to skip x86. Useful options: next-promoter-docker,ec2-fleet-next,packager')
		string(name: 'ARM_NODE_PARAM', defaultValue: 'armv8', description: 'Node or label to build arm. Use "NONE" to skip arm. Useful options: armv8')

		// Optional
		string(name: 'TIMEOUT_PARAM', defaultValue: '6', description: 'Build timeout (Timeout in hours)')
		booleanParam(name: 'RUN_DOWNSTREAM_JOBS', defaultValue: false, description: 'Unset this to avoid calling all downstream jobs - run only this build')
		booleanParam(name: 'RUN_PACKAGE_JOBS', defaultValue: true, description: 'Unset this to avoid calling package downstream jobs (Not relevant if RUN_DOWNSTREAM_JOBS is set) - run only this build')
		booleanParam(name: 'TEST_DEBUG_INFO', defaultValue: false, description: 'Set this to get full test debug info (+ 200 GB on disk).')
		string(name: 'X86_NUM_OF_UNITTEST_REPEATS', defaultValue: '1', description: 'Define the number of repeats for each test in unittests on X86 architecture. Use 0 to skip running the tests altogether.')
		string(name: 'ARM_NUM_OF_UNITTEST_REPEATS', defaultValue: '1', description: 'Define the number of repeats for each test in unittests on ARM architecture. Use 0 to skip running the tests altogether.')
		string(name: 'INCLUDE_TESTS', defaultValue: '' , description: 'Specify which tests to run. Leave empty for all. example: database_test')
		string(name: 'SCYLLA_BRANCH', defaultValue: '', description: 'Branch for Scylla. If empty - will take stable branch (master)')
		string(name: 'RELENG_REPO', defaultValue: '', description: 'Branch of pkg repo or fork. If empty - will take scylla-pkg repo (examples: git@github.com:scylladb/scylla-pkg, git@github.com:scylladb/scylla-enterprise-pkg, git@github.com:hagitsegev/scylla-pkg)')
		string(name: 'RELENG_BRANCH', defaultValue: '', description: 'Branch of pkg repo. If empty - will take stable branch (master)')
		booleanParam(name: 'PRESERVE_WORKSPACE', defaultValue: false, description: 'Check this if you need the workspace to remain (for debug)')
		booleanParam(name: 'DEBUG_MAIL', defaultValue: false, description: 'Uncheck if you want mail to rnd-int. Default is to sent to build requester only (you).')
		booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Check this to check pipeline syntax. will not perform anything.')
	}
	agent {
    label {
			label "built-in"
		}
	}

	environment {
		AWS_ACCESS_KEY_ID      = credentials('jenkins2-aws-secret-key-id')
		AWS_SECRET_ACCESS_KEY  = credentials('jenkins2-aws-secret-access-key')
	}
	options {
		disableConcurrentBuilds()
		timeout(time: env.TIMEOUT_PARAM, unit: 'HOURS')
		buildDiscarder(
			logRotator(
				numToKeepStr: '10',
				daysToKeepStr: env.JOB_NAME.contains("releng-testing") ? '14': ''
			)
		)
		copyArtifactPermission('*centos-rpm*,*dtest*,*unified-deb*,*unittests*,*driver-matrix*,*byo*,*microbenchmarks*,*release*,*offline-installer*,*docker*')
	}

	stages {

		stage ('Prepare') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					general = load "${generalProperties.groovyPath}/general.groovy"
					general.initPipeline()

					gitRepoShaFilePath = "$WORKSPACE/${gitProperties.scyllaPkgCheckoutDir}/${generalProperties.gitRepoShaFileName}"
					buildX86 = params.X86_NODE_PARAM != "NONE"
					buildArm = params.ARM_NODE_PARAM != "NONE"
					if (!armSupported) {
						echo "Currently not supporting ARM on this release"
						buildArm = false
					}
					x86TestsFailed = false
					x86AllTestResultDetails = ""
					armTestsFailed = false
					armAllTestResultDetails = ""

					buildTestModesList = general.buildModesList("") // test all: release, debug, dev
					buildTestModesString = buildTestModesList.join(", ")
					(utcTextTimeStamp, urlId) = artifact.cloudBuildIdPath ()
					targetRelocUrl = general.setTestingUrlIfNeeded ("${branchProperties.relocPackageCloudPathPrefix}/$urlId")
					targetBuildPackagesUrl = general.setTestingUrlIfNeeded ("${branchProperties.buildPackagesCloudPathPrefix}/$urlId")

					// As we later split the pipeline to run on 2 architectures (ARM and X86),
					// We want both processes to use the same Scylla and pkg SHAs - so get it here for both.
					scyllaBranch = params.SCYLLA_BRANCH ?: branchProperties.stableBranchName
					scyllaSha = git.remoteBranchSha(gitProperties.scyllaRepoUrl, scyllaBranch)
					pkgSha = git.remoteBranchSha(relengRepo, relengBranch)
					jobSummaryFile = "$WORKSPACE/${generalProperties.jobSummaryFile}"
					git.createJobSummaryFiles(jobSummaryFile, scyllaSha, branchProperties.stableBranchName)
				}
			}
		}

		stage('Build, Test, Publish') {
			parallel {
				stage ('buildTestPublishX86') {
					when {
						expression { buildX86 }
					}
					steps {
						node(params.X86_NODE_PARAM) {
							script {
								lastStage = "build and publish"
								if (buildArm) {
									architecture = generalProperties.x86ArchName
								} else {
									architecture = ""
								}
								(x86TestsFailed, x86AllTestResultDetails) = build.buildTestDtestPublish (
									dryRun: params.DRY_RUN,
									preserveWorkspace: params.PRESERVE_WORKSPACE,
									scyllaSha: scyllaSha,
									pkgSha: pkgSha,
									testsDebugInfoFlag: params.TEST_DEBUG_INFO,
									buildMode: "",
									architecture: architecture,
									urlId: urlId,
									utcTextTimeStamp: utcTextTimeStamp,
									targetRelocUrl: targetRelocUrl,
									targetBuildPackagesUrl: targetBuildPackagesUrl,
									numOfUnittestsRepeats: params.X86_NUM_OF_UNITTEST_REPEATS,
									includeTests: params.INCLUDE_TESTS,
									publishArtifacts: true,
									jobTitle: jobTitle,
									devAddress: devAddress,
									buildDocker: true,
								)
							}
						}
					}
				}

				stage ('buildTestPublishArm') {
					when {
						expression { buildArm }
					}
					steps {
						node(params.ARM_NODE_PARAM) {
							script {
								lastStage = "build and publish"
								(armTestsFailed, armAllTestResultDetails) = build.buildTestDtestPublish (
									dryRun: params.DRY_RUN,
									preserveWorkspace: params.PRESERVE_WORKSPACE,
									scyllaSha: scyllaSha,
									pkgSha: pkgSha,
									testsDebugInfoFlag: params.TEST_DEBUG_INFO,
									buildMode: "",
									architecture: generalProperties.armArchName,
									urlId: urlId,
									utcTextTimeStamp: utcTextTimeStamp,
									targetRelocUrl: targetRelocUrl,
									targetBuildPackagesUrl: targetBuildPackagesUrl,
									numOfUnittestsRepeats: params.ARM_NUM_OF_UNITTEST_REPEATS,
									includeTests: params.INCLUDE_TESTS,
									publishArtifacts: true,
									jobTitle: jobTitle,
									devAddress: devAddress,
									buildDocker: true,
								)
							}
						}
					}
				}
			}
		}

		stage('Build multi-arch docker image') {
			when {
				expression { buildArm }
			}
			steps {
				node('packager') {
					script {
						git.cleanWorkSpaceUponRequest()
						general.runOrDryRunSh (false, "mkdir -p $WORKSPACE", "Create an empty $WORKSPACE dir")
						boolean failedDocker = false
						String failedDockerText = ""
						try {
							def metadataFiles = [generalProperties.x86MetadataFile, generalProperties.armMetadataFile]
							jenkins.mergeFiles (
								dryRun: params.DRY_RUN,
								filesToMerge: metadataFiles,
								targetFile: generalProperties.buildMetadataFile,
							)

							build.createDockerManifest(params.DRY_RUN)
						} catch (error) {
							failedDockerText = "Error building multi-arch docker image error: |$error|"
							failedDocker = true
						} finally {
							artifact.publishMetadataFile(generalProperties.buildMetadataFile, targetRelocUrl, targetBuildPackagesUrl)
						}
						if (failedDocker) {
							error (failedDockerText)
						}
					}
				}
			}
		}

		stage('Check Tests Status') {
			when {
				expression { params.X86_NUM_OF_UNITTEST_REPEATS != "0" || params.ARM_NUM_OF_UNITTEST_REPEATS != "0" }
			}
			steps {
				script {
					if (x86TestsFailed && armTestsFailed) {
						lastStage = "Test x86 and arm"
						error ("Both x86 and arm tests failed:\n$x86AllTestResultDetails\n$armAllTestResultDetails")
					} else if (x86TestsFailed) {
						lastStage = "Test x86"
						error ("x86 tests failed:\n$x86AllTestResultDetails")
					} else if (armTestsFailed) {
						lastStage = "Test arm"
						error ("arm tests failed:\n$armAllTestResultDetails")
					}
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('initPipelineDone')) {
					jenkins.isSpotTermination(lastStage)
					jenkins.setUnstableAsError(jobTitle)

					if (buildArm) {
						def summaryFiles = []
						summaryFiles << generalProperties.armJobSummaryFile
						if (buildX86) {
							summaryFiles << generalProperties.x86JobSummaryFile
						}
						jenkins.mergeFiles (
							dryRun: params.DRY_RUN,
							filesToMerge: summaryFiles,
							targetFile: generalProperties.jobSummaryFile,
						)
					}

					logText += general.runOrDryRunShOutput (false, "cat $generalProperties.jobSummaryFile", "Get job summary for mail")
					echo "Job Summary:"
					echo "=================================="
					echo "$logText"
					echo "=================================="
					mail.mailIfError("$devAddress", "${currentBuild.currentResult} stage $lastStage: $jobTitle", "${currentBuild.currentResult}: $jobTitle on stage $lastStage\n$logText")

					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
				} else if (!(JOB_NAME.contains("releng-testing") || params.DRY_RUN || params.DEBUG_MAIL)) {
					mail (
						to: "releng@scylladb.com",
						subject: "${currentBuild.currentResult}: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
						body: "${env.JOB_NAME} [${env.BUILD_NUMBER}] ${currentBuild.currentResult} at the very beginning. Please see Jenkins logs for details"
					)
					jobSummaryFile = "$WORKSPACE/job-summary-results.properties"
					sh """
						echo 'lastStage=Early stage' >> $jobSummaryFile
						echo 'result=$currentBuild.currentResult' >> $jobSummaryFile
					"""
					archiveArtifacts "job-summary-results.properties"
					cleanWs()
				} else {
					cleanWs()
				}
			}
		}

		fixed {
			script {
				mail.mailFixed("$devAddress", "Fixed ${currentBuild.currentResult}: $jobTitle", "Fixed ${currentBuild.currentResult}: $jobTitle")
			}
		}

		success {
			script {
				startDownstreamJobs ()
			}
		}

		unstable {
			script {
				startDownstreamJobs ()
			}
		}
	}
}

def startDownstreamJobs () {
	String buildsToRun=""
	String artifactWebUrl=""
	if (params.RUN_DOWNSTREAM_JOBS) {
		buildsToRun=branchProperties.relocDependentJobs
		artifactWebUrl=targetRelocUrl
	} else if (params.RUN_PACKAGE_JOBS) {
		buildsToRun=branchProperties.buildBasedBuilds
		artifactWebUrl=targetBuildPackagesUrl
	}
	if (buildsToRun) {
		jenkins.runBuilds(dryRun: params.DRY_RUN,
			waitForLongBuilds: false,
			failIfCallFailed: false,
			buildShouldCallDependentJobs: true,
			buildsToRun: buildsToRun,
			artifactSourceJob: "$calledBuildsDir${branchProperties.buildJobName}",
			artifactWebUrl: artifactWebUrl,
			relengRepo: relengRepo,
			relengBranch: pkgSha,
			scyllaBranch: scyllaSha,
			calledBuildsDir: calledBuildsDir,
			artifactSourceJobNum: env.BUILD_NUMBER)
	} else {
		echo "Skipping calling downstream jobs due to user request"
	}
}
