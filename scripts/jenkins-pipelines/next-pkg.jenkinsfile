#!groovy
// Pipeline next
// In order to debug, set RELENG_BRANCH on Jenkins job with value of the debug branch.
// example: refs/heads/build-pipeline-into-scm
// If you work on a fork, also set the RELENG_REPO with your fork such as git@github.com:hagitsegev/scylla-pkg or
// use the default repo of git@github.com:scylladb/scylla-pkg or git@github.com:scylladb/scylla-enterprise-pkg

Map modules = [:]
pipeline {
	parameters {
		// Mandatory
		string(name: 'RELENG_REPO', defaultValue: '', description: 'Branch of pkg repo or fork. If empty - will take scylla-pkg repo (examples: git@github.com:scylladb/scylla-pkg, git@github.com:scylladb/scylla-enterprise-pkg, git@github.com:hagitsegev/scylla-pkg)')
		string(name: 'RELENG_BRANCH', defaultValue: '', description: 'Mandatory Branch of pkg repo.')
		// Optional
		booleanParam(name: 'SKIP_DRYRUN_DAILIES_ON_DEBUG', defaultValue: false, description: 'Check this to skip running all daily driven and byo pipelines in dry run.')
		booleanParam(name: 'SKIP_DRYRUN_RELEASE_ON_DEBUG', defaultValue: false, description: 'Check this to skip running release pipelines in dry run.')
		booleanParam(name: 'SKIP_BUILD_AND_TESTS_ON_DEBUG', defaultValue: false, description: 'Check this to skip build.')
		booleanParam(name: 'SKIP_TESTS_ON_DEBUG', defaultValue: false, description: 'Check this to skip unittests and dtest.')
		booleanParam(name: 'SKIP_BUILD_CENTOS_UNIFIED_ON_DEBUG', defaultValue: false, description: 'Check this to skip building CentOS and Unified-deb.')
		booleanParam(name: 'SKIP_BUILD_CENTOS_BASED_JOBS_ON_DEBUG', defaultValue: false, description: 'Check this to skip building CentOS based jobs (AMI, Docker, GCE).')
		booleanParam(name: 'SKIP_ARTIFACT_TESTS', defaultValue: false, description: 'Check this to skip all artifact tests.')
		booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Check this to check pipeline syntax. will not perform anything.')
		booleanParam(name: 'DEBUG_MAIL', defaultValue: true, description: 'Uncheck if you want mail to rnd-int. Default is to sent to build requester only (you).')
	}
	agent {
		label {
			label "built-in"
		}
	}

	options {
		disableConcurrentBuilds()
		timeout(time: 10, unit: 'HOURS')
		buildDiscarder(
			logRotator(
				numToKeepStr: '10',
				daysToKeepStr: env.JOB_NAME.contains("releng-testing") ? '14': ''
			)
		)
	}

	stages {
		stage ('Prepare') {
			steps {
				script {
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					general = load "${generalProperties.groovyPath}/general.groovy"
					general.initPipeline()

					artifactSourceJobPath = "${branchProperties.relengDebugCalledBuildsDir}${branchProperties.buildJobName}"
					artifactSourceJobID = "" // Will be set later if we call build, or latest success if not
					if (params.DRY_RUN || params.SKIP_BUILD_AND_TESTS_ON_DEBUG) {
						artifactSourceJobPath = "${branchProperties.calledBuildsDir}${branchProperties.relocUploaderJobName}"
					}
					baseCentosJobPath = "${branchProperties.relengDebugCalledBuildsDir}${branchProperties.centosJobName}"
					if (params.DRY_RUN || params.SKIP_BUILD_CENTOS_UNIFIED_ON_DEBUG) {
						baseCentosJobPath = "${branchProperties.calledBuildsDir}${branchProperties.centosJobName}"
					}
					unittestToDebug = ""

					general.errorIfMissingParam(params.RELENG_REPO, "RELENG_REPO")
					general.errorIfMissingParam(params.RELENG_BRANCH, "RELENG_BRANCH")
				}
			}
		}

		stage('Checkout') {
			steps {
				script {
					lastStage = env.STAGE_NAME
					git.cleanWorkSpaceUponRequest(false)
					git.checkoutToDir (params.RELENG_REPO, params.RELENG_BRANCH, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)
					general.lsPath (WORKSPACE, "Workspace content after check-outs")
				}
			}
		}

		stage('Dry-run Daily Jobs') {
			when {
				expression {!params.SKIP_DRYRUN_DAILIES_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					if (params.DRY_RUN) {
						echo "Skipping on dry run: dry-run jobs ${branchProperties.dryRunTestByPkgNextJobs} on ${branchProperties.relengDebugCalledBuildsDi}"
					} else {
						jenkins.runBuilds(dryRun: true,
							waitForLongBuilds: true,
							failIfCallFailed: true,
							buildShouldCallDependentJobs: true,
							buildsToRun: branchProperties.dryRunTestByPkgNextJobs,
							artifactSourceJob: "",
							artifactSourceJobNum: "",
							calledBuildsDir: branchProperties.relengDebugCalledBuildsDir,
							relengRepo: params.RELENG_REPO,
							relengBranch: params.RELENG_BRANCH)
					}
				}
			}
		}

		stage('Dry-run Release Jobs') {
			when {
				expression {!params.SKIP_DRYRUN_RELEASE_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					jenkins.runBuilds(dryRun: true,
						waitForLongBuilds: true,
						failIfCallFailed: true,
						buildShouldCallDependentJobs: false,
						buildsToRun: branchProperties.packageReleaseJob,
						relengRepo: params.RELENG_REPO,
						relengBranch: params.RELENG_BRANCH,
						calledBuildsDir: branchProperties.relengDebugCalledBuildsDir
					)

					jenkins.runBuilds(dryRun: true,
						waitForLongBuilds: true,
						failIfCallFailed: true,
						buildsToRun: branchProperties.promoteReleaseJob,
						relengRepo: params.RELENG_REPO,
						relengBranch: params.RELENG_BRANCH,
						calledBuildsDir: branchProperties.relengDebugCalledBuildsDir
					)
				}
			}
		}

		stage('Run Build') {
			when {
				expression {! params.SKIP_BUILD_AND_TESTS_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					if (params.DRY_RUN) {
						echo "Skipping on dry run: build job ${branchProperties.relengDebugCalledBuildsDir}${branchProperties.buildJobName}"
					} else {
						numOfUnitest = "1"
						unittestToDebug = "database_test"
						if (params.SKIP_TESTS_ON_DEBUG) {
							numOfUnitest = "0"
						}
						jobResults=build job: "${branchProperties.relengDebugCalledBuildsDir}${branchProperties.buildJobName}",
							parameters: [
								[$class: 'StringParameterValue', name: 'SCYLLA_BRANCH', value: branchProperties.stableBranchName], // Needed for build, dtest
								[$class: 'StringParameterValue', name: 'X86_NODE_PARAM', value: generalProperties.x86TargetBuildBuilder], // as we usually wait for these - make it on a faster agent
								[$class: 'StringParameterValue', name: 'ARM_NODE_PARAM', value: generalProperties.armTargetBuildBuilder], // as we usually wait for these - make it on a faster agent
								[$class: 'StringParameterValue', name: 'RELENG_REPO', value: params.RELENG_REPO],	// Needed for debug jobs
								[$class: 'StringParameterValue', name: 'RELENG_BRANCH', value: params.RELENG_BRANCH],	// Needed for debug jobs
								[$class: 'StringParameterValue', name: 'X86_NUM_OF_UNITTEST_REPEATS', value: numOfUnitest],	// Needed for debug jobs
								[$class: 'StringParameterValue', name: 'ARM_NUM_OF_UNITTEST_REPEATS', value: numOfUnitest],	// Needed for debug jobs
								[$class: 'StringParameterValue', name: 'INCLUDE_TESTS', value: unittestToDebug],	// Needed for debug jobs
								[$class: 'BooleanParameterValue', name: 'RUN_DOWNSTREAM_JOBS', value: false], // Needed for build
								[$class: 'BooleanParameterValue', name: 'RUN_PACKAGE_JOBS', value: false], // Needed for build
								[$class: 'BooleanParameterValue', name: 'DRY_RUN', value: params.DRY_RUN], // Run jobs as dry run
								[$class: 'BooleanParameterValue', name: 'PUBLISH_EVEN_ON_DEBUG', value: true], // publish the results, as we need them to debug
							],
							propagate: true, // I don't want to fail caller if a sub-job failed to run. But I want to fail if could not run at all. So I can't use true here + try & catch on caller.
							wait: true
							artifactSourceJobID = jobResults.number.toString()
					}
				}
			}
		}

		stage('Smoke dtest') {
			when {
				expression {! params.SKIP_TESTS_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					jenkins.runBuilds(dryRun: params.DRY_RUN,
						waitForLongBuilds: true,
						failIfCallFailed: true,
						calledBuildsDir: branchProperties.relengDebugCalledBuildsDir,
						buildsToRun: branchProperties.dtestReleaseJobName,
						artifactSourceJob: artifactSourceJobPath,
						artifactSourceJobNum: artifactSourceJobID,
						x86TargetNode: branchProperties.packagerJenkinsLabel,
						relengRepo: params.RELENG_REPO,
						relengBranch: params.RELENG_BRANCH
					)
				}
			}
		}

		stage('Run CentOs Unified') {
			when {
				expression {! params.SKIP_BUILD_CENTOS_UNIFIED_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					if (params.DRY_RUN) {
						echo "Skipping on dry run: full jobs ${branchProperties.fullTestByPkgNextArtifactJobs1} on ${branchProperties.relengDebugCalledBuildsDir}"
					} else {
						jenkins.runBuilds(dryRun: false,
							waitForLongBuilds: true,
							failIfCallFailed: true,
							buildShouldCallDependentJobs: false,
							buildsToRun: branchProperties.fullTestByPkgNextArtifactJobs1,
							artifactSourceJob: artifactSourceJobPath,
							artifactSourceJobNum: artifactSourceJobID,
							calledBuildsDir: branchProperties.relengDebugCalledBuildsDir,
							skipTests: params.SKIP_ARTIFACT_TESTS,
							relengRepo: params.RELENG_REPO,
							relengBranch: params.RELENG_BRANCH)
					}
				}
			}
		}

		stage('Run CentOS Based builds') {
			when {
				expression {! params.SKIP_BUILD_CENTOS_BASED_JOBS_ON_DEBUG}
			}
			steps {
				script {
					lastStage = env.STAGE_NAME
					if (params.DRY_RUN) {
						echo "Skipping on dry run: full jobs ${branchProperties.jobsCalledByCentOSRpmBuild} on ${branchProperties.relengDebugCalledBuildsDir}"
					} else {
						rpmUrl = artifact.fetchMetadataValue (
							downloadFromCloud: false,
							artifactSourceJob: baseCentosJobPath,
							fieldName: "centos-rpm-url:"
						)

						jenkins.runBuilds(dryRun: false,
							waitForLongBuilds: true,
							failIfCallFailed: true,
							buildShouldCallDependentJobs: false,
							buildsToRun: branchProperties.jobsCalledByCentOSRpmBuild,
							artifactSourceJob: "",
							artifactSourceJobNum: "",
							relengRepo: params.RELENG_REPO,
							relengBranch: params.RELENG_BRANCH,
							calledBuildsDir: branchProperties.relengDebugCalledBuildsDir,
							artifactWebUrl: rpmUrl,
							dockerReleaseName: branchProperties.dockerReleaseName,
							skipTests: params.SKIP_ARTIFACT_TESTS,
						)
					}
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('initPipelineDone')) {
					echo "Last stage: |$lastStage|"
					git.cleanWorkSpaceUponRequest(false)
				} else {
					cleanWs()
				}
			}
		}

		fixed {
			script {
				mail.mailFixed("$devAddress", "Fixed ${currentBuild.currentResult}: $jobTitle", "Fixed ${currentBuild.currentResult}: $jobTitle: $logText")
			}
		}
	}
}
