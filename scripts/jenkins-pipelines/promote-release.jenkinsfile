#!groovy
// Pipeline promote-release

Map modules = [:]
pipeline {
	parameters {
		string(name: 'VERSION_ID', defaultValue: '', description: 'Name of the release. Examples: 3.0.5, 2018.1.13, 3.1.rc1')

		// Based build Number numbers
		string(name: 'PACKAGE_RELEASE_BUILD_NUM', defaultValue: '', description: 'Number of package-release build (to take SHAs from). Default: latest')
		string(name: 'RELOC_BUILD_NUM', defaultValue: '', description: 'Number of build to take reloc from. Type none to skip promoting the reloc package.')
		string(name: 'UNIFIED_DEB_BUILD_NUM', defaultValue: '', description: 'Number of Unified Debian (Ubuntu and Debian) build to promote. Type none to skip promoting.')
		string(name: 'CENTOS_BUILD_NUM', defaultValue: '', description: 'Number of centos build to promote. Type none to skip promoting.')
		string(name: 'AMI_BUILD_NUM', defaultValue: '', description: 'AMI build to take AMI ID from. Type none to skip promoting.')
		string(name: 'GCE_IMAGE_BUILD_NUM', defaultValue: '', description: 'GCE image build to take GCE ID from. Type none to skip promoting.')
		string(name: 'DOCKER_BUILD_NUM', defaultValue: '', description: 'Number of Docker build to promote. Type none to skip promoting.')

		// General run parameters
		string(name: 'NODE_PARAM', defaultValue: 'ec2-fleet-promotion', description: 'On which node to run. Should run on AWS as it is faster to upload and download. If not available use aws-scylla-qa-builder5')
		string(name: 'RELENG_REPO', defaultValue: '', description: 'Branch of pkg repo or fork. If empty - will take scylla-pkg repo (examples: git@github.com:scylladb/scylla-pkg, git@github.com:scylladb/scylla-enterprise-pkg, git@github.com:hagitsegev/scylla-pkg)')
		string(name: 'RELENG_BRANCH', defaultValue: '', description: 'From where to run the package script and pipeline.')
		booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Set to test the pipeline code')
		booleanParam(name: 'PRESERVE_WORKSPACE_AFTER', defaultValue: false, description: 'Set to avoid cleaning workspace, for debug needs')
		booleanParam(name: 'DEBUG_MAIL', defaultValue: false, description: 'Set to send mails to requester only')

		// Parameters to enable skipping some parts:
		booleanParam(name: 'SKIP_PROMOTE', defaultValue: false, description: 'Set to skip promote builds.')
		booleanParam(name: 'SKIP_EC2AMI', defaultValue: false, description: 'Set to skip AMI copy')
		booleanParam(name: 'SKIP_GCE', defaultValue: false, description: 'Set to skip GCE copy')
		booleanParam(name: 'SKIP_PROMOTE_TEST', defaultValue: false, description: 'Set to skip private repo tests.')
		booleanParam(name: 'SKIP_DOCKER', defaultValue: false, description: 'Set to skip docker build and publish')
		booleanParam(name: 'SKIP_DOCKER_VERSION_TEST', defaultValue: false, description: 'Set to skip docker version test')
		booleanParam(name: 'SKIP_PROMOTE_LATEST_DOCKER', defaultValue: false, description: 'Set to skip promote docker to latest. Relevant on the latest releases only')
		booleanParam(name: 'SKIP_TAG', defaultValue: false, description: 'Set to skip tagging the release on git')
		booleanParam(name: 'SKIP_HOUSEKEEPING_VERSION', defaultValue: false, description: 'Set to skip update HouseKeeping version')
	}
	agent {
		label {
			label "${env.NODE_PARAM}"
		}
	}

	options {
		disableConcurrentBuilds()
		timeout(time: 4, unit: 'HOURS')
		buildDiscarder(logRotator(numToKeepStr: '20'))
		parallelsAlwaysFailFast()
	}

	stages {
		stage ('Prepare') {
			steps {
				script {
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					release = load "${generalProperties.groovyPath}/release.groovy"
					release.initPromotePipeline()

					relengRepo = params.RELENG_REPO ?: gitProperties.scyllaPkgRepoUrl
					relengBranch = params.RELENG_BRANCH ?: branchProperties.stableBranchName
					// I don't want to mix scripts repo (might be on debug mode) and prod repo, so I checkout twice.
					git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgScriptsCheckoutDir, disableSubmodules)
					// Override branch properties on debug run
					release.setDebugProperties(debugRun)
					calledBuildsDir = jenkins.prodOrDebugFolders(debugOrDryRun)

					release.initPromoteBuilds()
					(jobTitle,logText,runningUserID,devAddress,relengAddress,qaAddress)=mail.setMailParameters(
						dryRun: debugOrDryRun,
						debugMail: params.DEBUG_MAIL,
						branch: versionId,
						devAddress: generalProperties.releasePromotionMail,
					)

					release.initMachineImageMetadataItems()
					release.initPackageMetadataItems()
					release.initReleaseSteps()
					release.initExpectedVersions()
					jenkins.checkAndTagAwsInstance(runningUserID)
				}
			}
		}

		stage('Checkout') {
			steps {
				script {
					git.checkoutToDir (gitProperties.scyllaRepoUrl, shaProperties.scylla_branch, gitProperties.scyllaCheckoutDir)
					git.checkoutToDir (gitProperties.scyllaMachineImageRepoUrl, shaProperties.scylla_machine_image_branch, gitProperties.scyllaMachineImageCheckoutDir)

					general.lsPath (WORKSPACE, "Workspace content after check-outs")
					shellScriptsDir = "$WORKSPACE/${gitProperties.scyllaPkgScriptsCheckoutDir}/${generalProperties.pipelinesShellPath}"
					dpackagerCommand = "$WORKSPACE/${gitProperties.scyllaPkgScriptsCheckoutDir}/${generalProperties.dpackagerPath}"
				}
			}
		}

		stage('Promote AMI images') {
		    when {
		        expression {! params.SKIP_EC2AMI}
		    }
		    environment {
				AWS_ACCESS_KEY_ID      = credentials('jenkins2-aws-secret-key-id')
				AWS_SECRET_ACCESS_KEY  = credentials('jenkins2-aws-secret-access-key')
			}
			steps {
			    script {
			        promoteEC2Error = false
				    dpackagerEc2Command = general.setAwsDpackagerCommand (dpackagerCommand)
				    amiNameVersion = "$branchProperties.amiName-${versionId}"

    				install.testAmiVersionTag (
	    				dryRun: debugOrDryRun,
		    		    amiImageId: amiId,
			    		dpackagerCommand: dpackagerCommand,
				    	amiRegion: generalProperties.amiDefaultTestRegion,
				    	expectedVersionID: unifiedDebScyllaReleaseId,
				    	expectedRelease: expectedUnifiedVersion,
				    )

				    scyllaBranch = git.shaValue(relengBranch) ?: branchProperties.stableBranchName
				    cloudformationGeneratedFile = "scylla_cluster_${versionId}_${unifiedDebScyllaReleaseId}.yaml"

				    echo "Promoting Scylla AMI ${generalProperties.amiRegion}/${amiId} as $amiNameVersion ..."
					scyllaBuildShaId = "${shaProperties.scylla_branch}"
				    dir("${gitProperties.scyllaPkgScriptsCheckoutDir}/${generalProperties.pipelinesPythonPath}") {
					    args =  "--scylla_source_ami_id=${amiProperties.scylla_ami_id} "
					    args += "--build_tag=${env.BUILD_TAG} "
					    args += "--scylla_branch=$scyllaBranch "
					    args += "--regions_file_path=$WORKSPACE/${amiAllIdsFile} "
					    args += "--scylla_ami_image_name=${amiNameVersion} "
					    args += "--cloudformation_template_file=$WORKSPACE/$gitProperties.scyllaMachineImageCheckoutDir/$generalProperties.cloudformationTemplateFilePath/scylla.yaml.j2 "
					    args += "--build_id=${env.BUILD_ID} "
					    args += "--git_commit=${shaProperties.scylla_branch} "
					    args += "--scylla_build_sha_id=${scyllaBuildShaId} "
					    args += "--promote=true"

					    try {
					        general.runOrDryRunSh(params.DRY_RUN, "bash -c ' set -o pipefail; $dpackagerEc2Command -- ./aws-ec2-copy-instances $args'", "Promote AMI to All Region")
					        artifact.generateCloudformationAndPublish(dpackagerEc2Command, cloudformationGeneratedFile, stableUnifiedDebUrl)
					    } catch (error) {
						    echo "promoteEC2Error error: |$error|"
						    promoteEC2Error = true
					    }
				    }

				    publishFailed = artifact.publishArtifactsStatus(amiAllIdsFile, WORKSPACE)
				    if (publishFailed) {
    				    echo = "Warning: Failed to publish some ami artifact(s)"
				    }
				    if (promoteEC2Error) {
					    error("promote-ec2 script failed")
				    }
				    promoteEc2AmiDone=true
			    }
			}
		}

		stage('Promotes') {
			when {
				expression {(! params.SKIP_PROMOTE) || (! params.SKIP_GCE)}
			}
			environment {
				AWS_ACCESS_KEY_ID      = credentials('jenkins2-aws-secret-key-id')
				AWS_SECRET_ACCESS_KEY  = credentials('jenkins2-aws-secret-access-key')
				SCYLLA_GPG_PRIVATE_KEY = credentials('scylladb-package-signing-key-2020')
				SCYLLA_GPG_PUBLIC_KEY  = credentials('scylladb-package-signing-key-2020-public')
				SCYLLA_GPG_KEYID       = credentials('scylladb-package-signing-key-2020-public-keyid')
				GOOGLE_APPLICATION_CREDENTIALS = credentials("${generalProperties.jenkinsGoogleApplicationKey}")
			}
			steps {
				parallel(
					PromoteArtifacts: {
						script {
							sh "echo 'Promoted addresses:' > $promoteAddressesFile"
							boolean debugMail = debugOrDryRun || params.DEBUG_MAIL
							startPromoteEmailAddress = release.getStartingPromoteEmailAddresses (debugMail)
							def subject = "Starting promotion process for ${versionId}${debugOrDryRunText}"
							def mailBody = subject
							mail.mailResults(startPromoteEmailAddress, "$subject", "$mailBody")

							scriptsPath = "$WORKSPACE/$gitProperties.scyllaPkgCheckoutDir/$generalProperties.pipelinesShellPath"
							dpackagerPromoteCommand = dpackagerCommand
							dpackagerPromoteCommand += " -e s3_path=\"/${unstableUnifiedDebUrl}\""
							dpackagerPromoteCommand = general.setGpgDpackagerCommand (dpackagerPromoteCommand)
							dpackagerPromoteCommand = general.setAwsDpackagerCommand (dpackagerPromoteCommand)

							if (params.SKIP_PROMOTE) {
								echo "Skipping PromoteArtifacts due to user request"
							} else {
								allOsesPromoteParams =  " --product-name=${branchProperties.productName}"
								allOsesPromoteParams += " --stable-downloads-url=${branchProperties.baseDownloadsUrl}"

								if (params.DRY_RUN) {
									allOsesPromoteParams += " --dry-run" // This will not do anything - so I send the production addresses (not the testing), to see the commands.
								}

								def listOses2Promote = [:]
								if (unstableCentosUrl) {
									listOses2Promote.centos = " --unstable-centos-url=${unstableCentosUrl} --stable-centos-url=${stableCentosUrl}"
								}
								if (unstableUnifiedDebUrl) {
									listOses2Promote.unified = " --unstable-unified-deb-url=${unstableUnifiedDebUrl} --stable-unified-deb-url=${stableUnifiedDebUrl}"
								}
								if (unstableRelocUrl) {
									listOses2Promote.reloc = " --unstable-reloc-url=${unstableRelocUrl} --stable-reloc-url=${stableRelocUrl} --reloc-version=$expectedRelocVersion.${relocScyllaRelease}"
								}
								promoteRelocError = false

								def parallelStableArtifactPromotes = [:]
									listOses2Promote.each { os2Promote, osParams ->
										parallelStableArtifactPromotes["${os2Promote}"] = { ->
											osPromoteParams = allOsesPromoteParams + osParams
											osAddressFile = "${promoteAddressesFileName}_${os2Promote}.txt"
											osLogFile = "${promoteAllOutputFileBaseName}_${os2Promote}.txt"
											osPromoteParams += " --addresses_file=${osAddressFile}"
											echo "Calling promote_relocatable_all.sh script with parameters: |${osPromoteParams}| output to $osLogFile"

											try {
												sh "$dpackagerPromoteCommand -- bash -c 'set -o pipefail; ${shellScriptsDir}/promote-relocatable-all.sh --release-name=$releaseNameFromVersionId $osPromoteParams 2>&1 | tee $WORKSPACE/$osLogFile'"
											} catch (error) {
												echo "promoteRelocError error: |$error|"
												promoteRelocError = promoteRelocError || true
											}
										}
									}
								parallel parallelStableArtifactPromotes
								sh "cat ${promoteAddressesFileName}_*.txt >> $promoteAddressesFile"
								if (promoteRelocError) {
									error("promote_relocatable_all.sh script failed")
								}
							}
						}
					},
					PromoteGCE: {
						script {
							if (params.SKIP_GCE || params.GCE_IMAGE_BUILD_NUM.toLowerCase() == "none") {
								echo "Skipping PromoteGCE due to user request"
							} else {
								jenkins.checkAndTagAwsInstance(runningUserID)
								echo "Checkout agent phase"
								echo "===================="
								git.cleanWorkSpaceUponRequest(preserveWorkspace)
								// local pkg on packager
								git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgScriptsCheckoutDir, disableSubmodules)
								// Check label before promotion
								install.testGceVersionLabel (
									dryRun: debugOrDryRun,
									gceImageDbUrl: gceImageDbUrl,
									dpackagerCommand: dpackagerCommand,
									expectedVersionID: unifiedDebScyllaReleaseId,
									expectedRelease: expectedUnifiedVersion,
								)

								promotedGceImageId = release.promotedGce (
									dryRun: debugOrDryRun,
									pkgCheckoutDir: "$WORKSPACE/${gitProperties.scyllaPkgScriptsCheckoutDir}",
									dpackagerCommand: dpackagerCommand,
									gceImageName: gceImageName,
									gceImageSourceId: gceImageSourceId,
									calledBuildsDir: calledBuildsDir,
								)
								promoteGceDone=true
								promotedGceDbUrl = "${generalProperties.gceImageDbBaseUrl}/$promotedGceImageId"
								install.testGceVersionLabel (
									dryRun: debugOrDryRun,
									gceImageDbUrl: promotedGceDbUrl,
									dpackagerCommand: dpackagerCommand,
									expectedVersionID: unifiedDebScyllaReleaseId,
									expectedRelease: expectedUnifiedVersion,
								)
								gceInfoText = "GCE image name: $gceImageName, image ID: $promotedGceImageId, Scylla Project ID: $branchProperties.gceImagesProjectName"
								echo "$gceInfoText"
								git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE_AFTER)
							}
						}
					}
				)
			}
		}

		stage('Check Promoted Artifacts') {
			when {
				expression {! params.SKIP_PROMOTE_TEST}
			}
			environment {
				AWS_ACCESS_KEY_ID      = credentials('jenkins2-aws-secret-key-id')
				AWS_SECRET_ACCESS_KEY  = credentials('jenkins2-aws-secret-access-key')
			}
			steps {
				script {
					oses2Test = "$branchProperties.supportedCentOsToTest,$branchProperties.supportedUnifiedOsToTestWithNames"
					debianScyllaListUrl = "${branchProperties.baseDownloadsUrl}/deb/debian/scylla-${releaseNameFromVersionId}"
					ubuntuScyllaListUrl = "${branchProperties.baseDownloadsUrl}/deb/ubuntu/scylla-${releaseNameFromVersionId}"

					ArrayList oses2TestList = oses2Test.split('\\,')
					def parallelCheckPromotedArtifacts = [:]
						oses2TestList.each { os2Test ->
							parallelCheckPromotedArtifacts["${os2Test}"] = { ->
								try {
									if (centosBuildNum && os2Test.contains("centos")) {
										String dockerLogFile = "${os2Test}_docker_build.log"
										install.installScyllaVersion (
											os2Test: os2Test,
											scyllaExpectedVersionId: expectedCentVersion,
											scyllaExpectedRelease: centosScyllaReleaseId,
											scyllaExpectedMode: "release",
											dockerLogFile: dockerLogFile,
											urlToInstall: centosScyllaRepoUrl,
											dryRun: params.DRY_RUN,
										)
									} else if (unifiedDebBuildNum) {
										def (osNumber, osName) = os2Test.tokenize( ':' )
										String ubuntuDebScyllaListUrl = "${debianScyllaListUrl}.list"
										String ubuntuDebDistScyllaListUrl = "${debianScyllaListUrl}-${osName}.list"
										if (osNumber.contains("ubuntu")) {
											ubuntuDebScyllaListUrl = "${ubuntuScyllaListUrl}.list"
											ubuntuDebDistScyllaListUrl = "${ubuntuScyllaListUrl}-${osName}.list"
										}
										// Test the new general scylla.list file
										String dockerLogFile = "common_list_${osNumber}_docker_build.log"
										install.installScyllaVersion (
											os2Test: osNumber,
											scyllaExpectedVersionId: expectedUnifiedVersion,
											scyllaExpectedRelease: unifiedDebScyllaReleaseId,
											scyllaExpectedMode: "release",
											dockerLogFile: dockerLogFile,
											urlToInstall: ubuntuDebScyllaListUrl,
											dryRun: params.DRY_RUN,
										)
										// Test the old specific for OS scylla.list file
										dockerLogFile = "specific_list_${osName}_docker_build.log"
										install.installScyllaVersion (
											os2Test: osNumber,
											scyllaExpectedVersionId: expectedUnifiedVersion,
											scyllaExpectedRelease: unifiedDebScyllaReleaseId,
											scyllaExpectedMode: "release",
											dockerLogFile: dockerLogFile,
											urlToInstall: ubuntuDebDistScyllaListUrl,
											dryRun: params.DRY_RUN,
										)
									}
									echo "Success installation check: $os2Test"
									passedInstallationTestOSes += "$os2Test, "
								} catch (error) {
									echo "Error installation check: $os2Test error: |$error|"
									failedInstallationTestOSes += "$os2Test, "
								}
							}
						};
					parallel parallelCheckPromotedArtifacts

					// Test get scylladb server script - RPM
					versionIdToTest = versionId
					if (jenkins.debugBuild ()) {
						versionIdToTest = expectedCentVersion
					}
					install.parallelTestScyllaVersion (
						dryRun: params.DRY_RUN,
						oses2Test: "${branchProperties.supportedCentOsToTest},${branchProperties.supportedRhelOsToTest},${branchProperties.supportedOracleLinuxOsToTest},${branchProperties.supportedAmazonLinuxOsToTest}",
						testGetScylladb: true,
						scyllaExpectedRelease: centosScyllaReleaseId,
						scyllaExpectedVersionId: expectedCentVersion,
						scyllaExpectedMode: "release",
						scyllaRepoOrListUrl: versionIdToTest,
						logFileWord: "test-get-scylladb",
						productName: branchProperties.productName,
						justPrintErrors: false,
					)

					// Test get scylladb server script - Deb
					install.parallelTestScyllaVersion (
						oses2Test: branchProperties.supportedUnifiedOsToTest,
						dryRun: params.DRY_RUN,
						testGetScylladb: true,
						scyllaExpectedVersionId: expectedUnifiedVersion,
						scyllaExpectedRelease: unifiedDebScyllaReleaseId,
						scyllaExpectedMode: "release",
						scyllaRepoOrListUrl: versionIdToTest,
						logFileWord: "test-get-scylladb",
						productName: branchProperties.productName,
						justPrintErrors: false,
					)

					if (unstableRelocUrl) {
						String expectedVersionDash = "${expectedRelocVersion}-${relocScyllaRelease}"
						String expectedVersionDot = "${expectedRelocVersion}.${relocScyllaRelease}"
						int expectedNumberOfItems = branchProperties.numberOfRelocPublicItems.toInteger()
						int relocNumOfItems = 0
						if (params.DRY_RUN) {
							relocNumOfItems = expectedNumberOfItems
						} else {
							relocNumOfItemsDash = sh(script: "aws s3 ls $stableRelocUrl/ | grep package-$expectedVersionDash | wc -l", returnStdout: true).trim().toInteger()
							relocNumOfItemsDot = sh(script: "aws s3 ls $stableRelocUrl/ | grep package-$expectedVersionDot | wc -l", returnStdout: true).trim().toInteger()
							relocNumOfItems = relocNumOfItemsDash + relocNumOfItemsDot
						}
						echo "Found $relocNumOfItems reloc items on stable $stableRelocUrl with $expectedVersionDash or ${expectedVersionDot}. Expecting $expectedNumberOfItems files."
						if (relocNumOfItems != expectedNumberOfItems) {
							echo "Error: Number of reloc packages is not as expected"
							failedInstallationTestOSes += "relocatable packages"
						} else {
							passedInstallationTestOSes += "relocatable packages"
						}
					}

					if (! failedInstallationTestOSes) {
						echo "All promoted installations |$passedInstallationTestOSes| were verified, and contain the right version"
						promoteArtifactsDone=true
					} else {
						error ("Some promoted versions do not contain the right version: |$failedInstallationTestOSes|. Passed: |$passedInstallationTestOSes|")
					}
				}
			}
		}

		stage('Promote Docker') {
			when {
				expression {! params.SKIP_DOCKER && params.DOCKER_BUILD_NUM.toLowerCase() != "none"}
			}
			steps {
				script {
					publishDockerParams =  "--container-tag-name=$containerTagName"
					publishDockerParams += " --release_name=${releaseNameFromVersionId}"
					publishDockerParams += " --stable_version_id=${versionId}"
					publishDockerParams += " --origin_container_repo=${branchProperties.containerRepository}"
					publishDockerParams += " --target_container_repo=${branchProperties.productName}"
					publishDockerParams += " --promote_stable"
					if (debugOrDryRun) {
						publishDockerParams += " --dry_run"
					}

					if (promoteToLatest){
						publishDockerParams += " --promote_latest"
					}

					build.publishDocker(
						scriptsDir: shellScriptsDir,
						defaultDir: "$WORKSPACE/${gitProperties.scyllaCheckoutDir}/dist/docker/redhat",
						scriptParams: publishDockerParams,
						testingEnv: debugOrDryRun)
				}
			}
		}

		stage('Test Docker Version') {
			when {
				expression {! params.SKIP_DOCKER_VERSION_TEST && params.DOCKER_BUILD_NUM.toLowerCase() != "none"}
			}
			steps {
				script {
					echo "Testing docker version before promote to latest (if needed)"
					install.testDockerVersion (
						dryRun: params.DRY_RUN,
						containerOrganizationImageName: "${generalProperties.containerOrganization}/${branchProperties.productName}:${versionId}",
						expectedVersionID: versionId,
						expectedRelease: centosScyllaReleaseId,
					)

					if (promoteToLatest){
						install.testDockerVersion (
							dryRun: params.DRY_RUN,
							containerOrganizationImageName: "${generalProperties.containerOrganization}/${branchProperties.productName}:latest",
							expectedVersionID: versionId,
							expectedRelease: centosScyllaReleaseId,
						)
					}
					dockerPromoted=true
				}
			}
		}

		stage('Tag Release') {
			when {
				expression {! params.SKIP_TAG}
			}
			environment {
				AWS_ACCESS_KEY_ID      = credentials('jenkins2-aws-secret-key-id')
				AWS_SECRET_ACCESS_KEY  = credentials('jenkins2-aws-secret-access-key')
			}

			steps {
				script {
					git.tagRepo(
						baseDir: gitProperties.scyllaCheckoutDir,
						repoUrl: gitProperties.scyllaRepoUrl,
						sha: shaProperties.scylla_branch,
						versionId: versionId,
						dryRun: debugOrDryRun )

					git.tagRepo(
						baseDir: gitProperties.scyllaMachineImageCheckoutDir,
						repoUrl: gitProperties.scyllaMachineImageRepoUrl,
						sha: shaProperties.scylla_machine_image_branch,
						versionId: versionId,
						dryRun: debugOrDryRun )

					tagCreated=true
				}
			}
		}

		stage('HouseKeeping Version') {
			when {
				expression {! params.SKIP_HOUSEKEEPING_VERSION}
			}
			environment {
				SCYLLA_USER    = credentials('houskeeping-version-scylla-user')
				SCYLLA_PASSWD  = credentials('houskeeping-version-scylla-pw')
			}
			steps {
				script {
					if (isRcVersion) {
						echo "Skipping Update housekeeping version as it is an RC release"
						if (isRcVersion) {
							houseKeepingUpdated=true
						}
					} else {
						housekeepingVersionParams =  "--full_version=${versionId}"
						if (isOpenSourceRelease) {
							housekeepingVersionParams += " --system=scylla"
						} else {
							housekeepingVersionParams += " --system=enterprise"
						}

						if (debugOrDryRun) {
							housekeepingVersionParams += " --dry_run" // This will not do anything - so I want to see the production target addresses.
							housekeepingVersionParams += " --sql_address=${generalProperties.mysqlHostUrl}"
						} else {
							housekeepingVersionParams += " --sql_address=${generalProperties.mysqlHostUrl}"
						}
						sh "$dpackagerCommand -e SCYLLA_USER=$SCYLLA_USER -e SCYLLA_PASSWD=$SCYLLA_PASSWD -- ${shellScriptsDir}/update-houskeeping-version.sh ${housekeepingVersionParams}"
						houseKeepingUpdated=true
					}
				}
			}
		}
		stage('Test scylladb installation Latest Version') {
			when {
				expression {promoteToLatest}
			}

			steps {
				script {
					// Test get scylladb server script - RPM
					install.parallelTestScyllaVersion (
						dryRun: params.DRY_RUN,
						oses2Test: "${branchProperties.supportedCentOsToTest},${branchProperties.supportedRhelOsToTest},${branchProperties.supportedOracleLinuxOsToTest},${branchProperties.supportedAmazonLinuxOsToTest}",
						testGetScylladb: true,
						scyllaExpectedRelease: centosScyllaReleaseId,
						scyllaExpectedVersionId: expectedCentVersion,
						scyllaExpectedMode: "release",
						scyllaRepoOrListUrl: "latest-official",
						logFileWord: "test-get-scylladb-latest",
						productName: branchProperties.productName,
						justPrintErrors: false,
					)

					// Test get scylladb server script - Deb
					install.parallelTestScyllaVersion (
						oses2Test: branchProperties.supportedUnifiedOsToTest,
						dryRun: params.DRY_RUN,
						testGetScylladb: true,
						scyllaExpectedVersionId: expectedUnifiedVersion,
						scyllaExpectedRelease: unifiedDebScyllaReleaseId,
						scyllaExpectedMode: "release",
						scyllaRepoOrListUrl: "latest-official",
						logFileWord: "test-get-scylladb-latest",
						productName: branchProperties.productName,
						justPrintErrors: false,
					)
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('runningUserID')) {
					mail.mailResults("$relengAddress", "${currentBuild.currentResult}: $jobTitle", "Release Process ${currentBuild.currentResult}")

					successAll = promoteArtifactsDone && promoteEc2AmiDone && promoteGceDone && dockerPromoted && tagCreated && houseKeepingUpdated
					String promoteEmailAddress=release.promotedEmailAddress(debugOrDryRun, successAll)
					String subject = "${branchProperties.productNameForMail} $versionId $debugOrDryRunText"
					String amiText = "Please see AMI list attached as a csv file.\n\n"

					if (successAll) {
						subject += " is promoted"
					} else {
						subject += " partially promoted but some part(s) failed / skipped"
					}
					String mailBody = "$subject\n\n"
					if (promoteEc2AmiDone || fileExists(amiAllIdsFile)) {
						mailBody += "\n$amiText"
						mailBody += sh(script: "echo 'Scylla Cloudformation (yaml) file: $stableUnifiedDebUrl$cloudformationGeneratedFile'", returnStdout: true).trim()
					}
					sh "echo $gceInfoText >> $promoteAddressesFile"
					if (promoteArtifactsDone || fileExists(promoteAddressesFile)) {
						mailBody += sh(script: "cat $promoteAddressesFile", returnStdout: true).trim()
						publishFailed = artifact.publishArtifactsStatus( "${promoteAllOutputFileBaseName}_*.txt", WORKSPACE)
						publishFailed |= artifact.publishArtifactsStatus(promoteAddressesFile, WORKSPACE)
						if (publishFailed) {
							echo = "Warning: Failed to publish some promote artifact(s)"
						}
					}

					mail.mailWithAttachedFile (
						address: promoteEmailAddress,
						title: subject,
						inputBody: mailBody,
						attachFile: amiAllIdsFile)

					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE_AFTER)
				} else if (!(JOB_NAME.contains("releng-testing") || params.DRY_RUN || params.DEBUG_MAIL)) {
					mail (
						to: "releng@scylladb.com",
						subject: "${currentBuild.currentResult}: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
						body: "${env.JOB_NAME} [${env.BUILD_NUMBER}] ${currentBuild.currentResult} at the very beginning. Please see Jenkins logs for details"
					)
					cleanWs()
				} else {
					cleanWs()
				}
			}
		}
	}
}
