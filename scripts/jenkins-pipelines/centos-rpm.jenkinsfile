#!groovy
// Pipeline cntos-rpm
// In order to debug, set branch on Jenkins job pipeline section and /or parameter with value of the debug branch.
// Parameter is used to run sh scripts, pipeline to checkout the pipeline and groovy functions.
// It is needed to be hard coded on pipeline, to enable each job to take its value of the branch,
// otherwise - value is deleted / get hte same value from the pipeline code each time it runs.
// example: refs/heads/build-pipeline-into-scm
// If you work on a fork, also set the RELENG_REPO with your fork such as git@github.com:hagitsegev/scylla-pkg or
// use the default repo of git@github.com:scylladb/scylla-pkg or git@github.com:scylladb/scylla-enterprise-pkg


Map modules = [:]
pipeline {
	parameters {
		// Mandatory:
		string(name: 'X86_NODE_PARAM', defaultValue: 'packager', description: 'On which node to run the build phase.')
		string(name: 'ARM_NODE_PARAM', defaultValue: 'armv8', description: 'Node or label to test installation on arm. Use "NONE" to skip. Useful options: armv8')
		// Optional
		string(name: 'CENTOS_VERSION', defaultValue: '7', description: 'On which CentOS version to run tests')
		string(name: 'SCYLLA_BRANCH', defaultValue: '', description: 'Branch for Scylla. If empty - will take stable branch (master)')
		string(name: 'MACHINE_IMAGE_BRANCH', defaultValue: '', description: 'Branch for ami. If empty - will take stable branch (master)')
		string(name: 'ARTIFACT_SOURCE_JOB_NAME', defaultValue: '', description: 'Build path to take artifacts from (usually next or build). Use this with ARTIFACT_SOURCE_BUILD_NUM to get reloc from jenkins, or ARTIFACT_WEB_URL to take them from cloud')
		string(name: 'ARTIFACT_SOURCE_BUILD_NUM', defaultValue: '', description: 'Build number to take artifacts from. Leave empty to use last available build. Use with ARTIFACT_SOURCE_JOB_NAME to take artifacts from Jenkins, or ARTIFACT_WEB_URL to take them from cloud.')
		string(name: 'ARTIFACT_WEB_URL', defaultValue: 'latest', description: 'URL to take reloc items from. Use when reloc is not available on jenkins, or when running on AWS, which will download faster from S3.')
		string(name: 'RELENG_REPO', defaultValue: '', description: 'Branch of pkg repo or fork. If empty - will take scylla-pkg repo (examples: git@github.com:scylladb/scylla-pkg, git@github.com:scylladb/scylla-enterprise-pkg, git@github.com:hagitsegev/scylla-pkg)')
		string(name: 'RELENG_BRANCH', defaultValue: '', description: 'Branch of pkg repo. If empty - will take master branch (master, branch-3.1)')
		booleanParam(name: 'BUILD_DEBUG', defaultValue: true, description: 'Set to create also debug RPMs')
		booleanParam(name: 'SKIP_TEST', defaultValue: false, description: 'Set to skip tests - for debug use')
		booleanParam(name: 'SKIP_ADDITIONAL_TESTS', defaultValue: false, description: 'Set to skip the additional tests (relevant when SKIP_TEST is not set) - for next-machine-image')
		booleanParam(name: 'SKIP_PROMOTE_LATEST', defaultValue: false, description: 'Set to skip promote to latest - for debug use')
		booleanParam(name: 'RUN_DOWNSTREAM_JOBS', defaultValue: true, description: 'Unset this to avoid calling downstream jobs')
		booleanParam(name: 'DRY_RUN', defaultValue: false, description: 'Set to test the pipeline code')
		booleanParam(name: 'SKIP_BUILD_ON_DEBUG', defaultValue: false, description: 'Set to use the last built packages and repo. For debug only.')
		booleanParam(name: 'INSTALLATION_TEST_FAIL_BUILD', defaultValue: true, description: 'Unset not to faile build if installation tests fail')
		booleanParam(name: 'X86_SKIP_INSTALL_TEST', defaultValue: false, description: 'Set to skip installation tests on X86 - for debug use')
		booleanParam(name: 'ARM_SKIP_INSTALL_TEST', defaultValue: false, description: 'Set to skip installation tests on X86 - for debug use')
		booleanParam(name: 'PRESERVE_WORKSPACE', defaultValue: false, description: 'Set to avoid cleaning workspace before and after run, for debug needs')
		booleanParam(name: 'DEBUG_MAIL', defaultValue: false, description: 'Set to send mails to requester only')
	}

	agent {
		label {
			label "built-in"
		}
	}

	environment {
		AWS_ACCESS_KEY_ID     = credentials('jenkins2-aws-secret-key-id')
		AWS_SECRET_ACCESS_KEY = credentials('jenkins2-aws-secret-access-key')
	}

	options {
		disableConcurrentBuilds()
		timeout(time: 360, unit: 'MINUTES')
		buildDiscarder(
			logRotator(
				numToKeepStr: '10',
				daysToKeepStr: env.JOB_NAME.contains("releng-testing") ? '14': ''
			)
		)
		copyArtifactPermission('*ami*,*docker*,*release*,*gce*')
	}

	stages {
		stage ('Prepare') {
			steps {
				script {
					generalProperties = readProperties file: 'scripts/jenkins-pipelines/general.properties'
					general = load "${generalProperties.groovyPath}/general.groovy"
					general.initPipeline()
					buildArm = params.ARM_NODE_PARAM != "NONE"
					if (!armSupported) {
						echo "Currently not supporting ARM on this release"
						buildArm = false
					}
					if (buildArm) {
						currentBuild.description = "X86 + ARM"
						artifactSourceJob = params.ARTIFACT_SOURCE_JOB_NAME ?: "${branchProperties.calledBuildsDir}${branchProperties.buildJobName}"
					} else {
						currentBuild.description = "X86 only"
						artifactSourceJob = params.ARTIFACT_SOURCE_JOB_NAME ?: "${branchProperties.calledBuildsDir}${branchProperties.relocUploaderJobName}"
					}

					justPrintErrors = (!params.INSTALLATION_TEST_FAIL_BUILD)
					scyllaBranch = params.SCYLLA_BRANCH ?: branchProperties.stableBranchName
					machineImageBranch = params.MACHINE_IMAGE_BRANCH ?: branchProperties.stableBranchName

					(qaJobProvisionType, qaNodesPostBehaviorType) = jenkins.setQAJobParameters()
					relengTestingRun = jenkins.debugBuild()
					artifactSourceJobNum = params.ARTIFACT_SOURCE_BUILD_NUM ?: Jenkins.instance.getItemByFullName(artifactSourceJob).lastSuccessfulBuild.number.toString()
					paramArtifactWebUrl = params.ARTIFACT_WEB_URL ?: "latest"
					cloudUrl = artifact.getLastSuccessfulUrl (
						artifactWebUrl: paramArtifactWebUrl,
						artifactSourceJob: artifactSourceJob,
						artifactSourceJobNum: artifactSourceJobNum,
						fieldName: "rpm-deb-pack-url:"
					)

					releaseShaId = artifact.fetchMetadataValue (
						downloadFromCloud: false,
						artifactSourceJob: artifactSourceJob,
						artifactSourceJobNum:artifactSourceJobNum,
						cloudUrl: cloudUrl,
						fieldName: "scylla-release:"
					)

					scyllaUrlID = artifact.fetchMetadataValue (
						downloadFromCloud: true,
						artifactSourceJob: artifactSourceJob,
						artifactSourceJobNum: artifactSourceJobNum,
						cloudUrl: cloudUrl,
						fieldName: "url-id:"
					)
					def version = artifact.fetchMetadataValue (
						downloadFromCloud: true,
						artifactSourceJob: artifactSourceJob,
						artifactSourceJobNum: artifactSourceJobNum,
						cloudUrl: cloudUrl,
						fieldName: "scylla-version:"
					)
					scyllaVersion = "${version}-${releaseShaId}"
					if (params.SKIP_BUILD_ON_DEBUG) {
						rpmUrl = "${branchProperties.scyllaDownloadsRpmUnstablePath}/$scyllaUrlID/"
					} else {
						rpmUrl = general.setTestingUrlIfNeeded ("${branchProperties.scyllaDownloadsRpmUnstablePath}/$scyllaUrlID/")
					}
					latestScyllaRpmRepoUrl = general.setTestingUrlIfNeeded ("${branchProperties.latestCentOSUrl}${branchProperties.repoFileName}")
					scyllaRepoHttpsS3 = general.setTestingUrlIfNeeded ("${branchProperties.scyllaDownloadsRpmUnstablePath}/$scyllaUrlID/${branchProperties.repoFileName}")
					scyllaRepoHttpsS3 = general.addHttpsS3PrefixIfMissing(scyllaRepoHttpsS3)

					artifact.addLineToBuildMetadataFile("centos-rpm-url", rpmUrl)
					scyllaRpmRepoUrl = "$rpmUrl${branchProperties.repoFileName}"
					artifact.addLineToBuildMetadataFile("centos-rpm-repo-url", scyllaRpmRepoUrl)
					if (params.BUILD_DEBUG) {
						debugScyllaRpmRepoUrl = "$rpmUrl${branchProperties.debugRepoFileName}"
						artifact.addLineToBuildMetadataFile("centos-rpm-debug-repo-url", debugScyllaRpmRepoUrl)
					}
					stash(name: generalProperties.buildMetadataFile, includes: generalProperties.buildMetadataFile)
				}
			}
		}

		stage('Checkout Server') {
			steps {
				script {
					// As we split the pipeline to run on jenkins server, and to do the build on a packager machine,
					// we need to checkout pkg twice, so scripts will be available both on server and packager.
					// Note that $WORKSPACE could be different on server and packager.
					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)
				}
			}
		}

		stage('Create Repo') {
			when {
				expression { !(relengTestingRun && params.SKIP_BUILD_ON_DEBUG) }
			}
			steps {
				script {
					node(params.X86_NODE_PARAM) {
						jenkins.checkAndTagAwsInstance(runningUserID)
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
						echo "Checkout agent phase"
						echo "===================="

						git.checkoutToDir(gitProperties.scyllaRepoUrl, scyllaBranch, gitProperties.scyllaCheckoutDir)
						git.checkoutToDir(gitProperties.scyllaMachineImageRepoUrl, machineImageBranch, gitProperties.scyllaMachineImageCheckoutDir)
						// local pkg on packager
						git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)
						unstash(name: generalProperties.buildMetadataFile)

						build.prepareBuildRpm (
							dryRun: params.DRY_RUN,
							mainMode: true,
							downloadFromCloud: true,
							cloudUrl: cloudUrl,
							artifactSourceJob: artifactSourceJob,
							artifactSourceJobNum: artifactSourceJobNum,
							scyllaUrlID: scyllaUrlID,
							rpmUrl: rpmUrl,
							buildMode: "release",
							buildArm: buildArm,
						)

						if (params.BUILD_DEBUG) {
							build.prepareBuildRpm (
								dryRun: params.DRY_RUN,
								mainMode: false,
								downloadFromCloud: true,
								cloudUrl: cloudUrl,
								artifactSourceJob: artifactSourceJob,
								artifactSourceJobNum: artifactSourceJobNum,
								scyllaUrlID: scyllaUrlID,
								rpmUrl: rpmUrl,
								buildMode: "debug",
								buildArm: buildArm,
							)
						}
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					}
				}
			}
		}

		stage('Test Repo X86') {
			when {
				expression {! params.X86_SKIP_INSTALL_TEST}
			}
			steps {
				script {
					node(params.X86_NODE_PARAM) {
						jenkins.checkAndTagAwsInstance(runningUserID)
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
						// local pkg on packager
						git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)

						install.parallelTestScyllaVersion (
							dryRun: params.DRY_RUN,
							oses2Test: branchProperties.supportedCentOsToTest,
							scyllaExpectedRelease: branchProperties.devReleaseName,
							scyllaExpectedVersionId: releaseShaId,
							scyllaExpectedMode: "release",
							scyllaRepoOrListUrl: scyllaRpmRepoUrl,
							logFileWord: "x86",
							justPrintErrors: justPrintErrors,
						)

						if (params.BUILD_DEBUG) {
							install.parallelTestScyllaVersion (
								dryRun: params.DRY_RUN,
								oses2Test: branchProperties.supportedCentOsToTest,
								scyllaExpectedRelease: branchProperties.devReleaseName,
								scyllaExpectedVersionId: releaseShaId,
								scyllaExpectedMode: "debug",
								scyllaRepoOrListUrl: debugScyllaRpmRepoUrl,
								logFileWord: "x86",
								justPrintErrors: true,
							)
						}
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					}
				}
			}
		}

		stage('Test Repo ARM') {
			when {
				expression {buildArm && (! params.ARM_SKIP_INSTALL_TEST)}
			}
			steps {
				node(params.ARM_NODE_PARAM) {
					script {
						jenkins.checkAndTagAwsInstance(runningUserID)
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
						// local pkg on packager
						git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)

						install.parallelTestScyllaVersion (
							dryRun: params.DRY_RUN,
							oses2Test: branchProperties.supportedCentOsToTest,
							scyllaExpectedRelease: branchProperties.devReleaseName,
							scyllaExpectedVersionId: releaseShaId,
							scyllaExpectedMode: "release",
							scyllaRepoOrListUrl: scyllaRpmRepoUrl,
							logFileWord: "arm",
							justPrintErrors: justPrintErrors,
						)

						if (params.BUILD_DEBUG) {
							install.parallelTestScyllaVersion (
								dryRun: params.DRY_RUN,
								oses2Test: branchProperties.supportedCentOsToTest,
								scyllaExpectedRelease: branchProperties.devReleaseName,
								scyllaExpectedVersionId: releaseShaId,
								scyllaExpectedMode: "debug",
								scyllaRepoOrListUrl: debugScyllaRpmRepoUrl,
								logFileWord: "arm",
								justPrintErrors: true,
							)
						}
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					}
				}
			}
		}

		stage ('CentOS RPM 7 test') {
			when {
				expression {! params.SKIP_TEST}
			}
			steps {
				script {
					jenkins.runTestJob (
						dryRun: params.DRY_RUN,
						failIfCallFailed: true,
						waitForLongBuilds: true,
						runJobsSerial: true,
						calledBuildsDir: calledBuildsDir,
						testsToRun: branchProperties.qaMadatoryArtifactsCalledByCentOSRpmBuild,
						qaJobProvisionType: qaJobProvisionType,
						qaNodesPostBehaviorType: qaNodesPostBehaviorType,
						urlParamName: "scylla_repo",
						urlParamValue: scyllaRepoHttpsS3,
					)
				}
			}
		}

		stage ('Promote to latest') {
			when {
				expression {! params.SKIP_PROMOTE_LATEST}
			}
			steps {
				script {
					node(params.X86_NODE_PARAM) {
						jenkins.checkAndTagAwsInstance(runningUserID)
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
						echo "Checkout pkg on agent"
						echo "===================="
						git.checkoutToDir (relengRepo, relengBranch, gitProperties.scyllaPkgCheckoutDir, disableSubmodules)

						artifact.promoteNightlyLatest(params.DRY_RUN, rpmUrl)

						oses2Test = branchProperties.supportedCentOsToTest
						oses2Test += ",${branchProperties.supportedRhelOsToTest},${branchProperties.supportedOracleLinuxOsToTest},${branchProperties.supportedAmazonLinuxOsToTest}"
						install.parallelTestScyllaVersion (
							dryRun: params.DRY_RUN,
							oses2Test: oses2Test,
							testGetScylladb: true,
							scyllaExpectedRelease: branchProperties.devReleaseName,
							scyllaExpectedVersionId: releaseShaId,
							scyllaExpectedMode: "release",
							scyllaRepoOrListUrl: "nightly-$branchProperties.releaseName",
							logFileWord: "latest-test-get-scylladb",
							productName: branchProperties.productName,
							justPrintErrors: justPrintErrors,
						)
						git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
					}
				}
			}
		}

		stage ('Trigger Downstream Jobs') {
			when {
				expression {params.RUN_DOWNSTREAM_JOBS}
			}
			steps {
				script {
					if ("${branchProperties.enableRollingUpgrade}".toBoolean()) {
						if (params.DRY_RUN){
							echo "Skipping Rolling upgrade as we run on dry run"
						} else {
							test.runRollingUpgradeJobs (
								rollingUpgradeList: branchProperties.centOSRollingUpgradeList,
								scyllaRepoUrl: scyllaRepoHttpsS3,
								qaJobProvisionType: qaJobProvisionType,
								qaNodesPostBehaviorType: qaNodesPostBehaviorType,
							)
						}
					} else {
						echo "By default rolling upgrade should not run on master, Skipping"
					}
				}
			}
		}

		stage ('CentOS RPM More tests') {
			when {
				expression {! params.SKIP_TEST && ! params.SKIP_ADDITIONAL_TESTS}
			}
			steps {
				script {
					jenkins.runTestJob (
						dryRun: params.DRY_RUN,
						failIfCallFailed: true,
						waitForLongBuilds: true,
						runJobsSerial: true,
						calledBuildsDir: calledBuildsDir,
						testsToRun: branchProperties.qaArtifactsCalledByCentOSRpmBuild,
						qaJobProvisionType: qaJobProvisionType,
						qaNodesPostBehaviorType: qaNodesPostBehaviorType,
						urlParamName: "scylla_repo",
						urlParamValue: scyllaRepoHttpsS3,
					)
				}
			}
		}
	}

	post {
		//Order is: always, changed, fixed, regression, aborted, failure, success, unstable, and cleanup.
		always {
			script {
				if (binding.hasVariable('initPipelineDone')) {
					jenkins.setUnstableAsError(jobTitle)
					mail.mailIfError("${devAddress}", "${currentBuild.currentResult}: $jobTitle", "${currentBuild.currentResult}: ${jobTitle}: $logText")
					git.cleanWorkSpaceUponRequest(params.PRESERVE_WORKSPACE)
				} else if (!(JOB_NAME.contains("releng-testing") || params.DRY_RUN || params.DEBUG_MAIL)) {
					mail (
						to: "releng@scylladb.com",
						subject: "${currentBuild.currentResult}: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
						body: "${env.JOB_NAME} [${env.BUILD_NUMBER}] ${currentBuild.currentResult} at the very beginning. Please see Jenkins logs for details"
					)
					cleanWs()
				} else {
					cleanWs()
				}
			}
		}

		fixed {
			script {
				mail.mailFixed("${devAddress}", "Fixed ${currentBuild.currentResult}: $jobTitle", "Fixed ${currentBuild.currentResult}: ${jobTitle}: $logText")
			}
		}
	}
}
